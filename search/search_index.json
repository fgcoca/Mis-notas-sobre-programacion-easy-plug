{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"1. Mis notas sobre programaci\u00f3n de la placa Easy Plug con ArduinoBlocks \u00b6 Estas notas se dedican a la programaci\u00f3n de la placa de control Ks0240 keyestudio EASY plug V2.0 con ArduinoBlocks a partir de diferentes actividades y/o retos incluyendo informaci\u00f3n b\u00e1sica de los componentes y de programaci\u00f3n de manera progresiva. 1.1. Elementos y componentes Easy Plug \u00b6 Easy Plug es una placa donde podemos conectar diferentes sensores y actuadores de forma muy sencilla. Adem\u00e1s, se pueden crear diferentes programas, proyectos y experimentos muy interesantes para ni\u00f1as y ni\u00f1os de los \u00faltimos cursos de Educaci\u00f3n Primaria as\u00ed como, durante la etapa de educaci\u00f3n secundaria. Sus caracter\u00edsticas t\u00e9cnicas principales son: Es compatible con Arduino Uno Cinco puertos digitales (de entrada y salida) Cuatro puertos de entrada anal\u00f3gica Un puerto SPI Un puerto I2C. Sus conectores son pines RJ-11 de cuatro hilos, lo que les hace mucho m\u00e1s f\u00e1ciles para conectarlos y evitar malas conexiones. En la Figura 1.1 vemos una imagen de la placa con r\u00f3tulos descriptivos de la misma. Figura 1.1. Descripci\u00f3n de la placa Easy Plug ArduinoBlocks: programa, acceso e interfaz \u00b6 Arduino es una plataforma de prototipos de c\u00f3digo abierto, basada en hardware y software flexibles y f\u00e1ciles de utilizar. Su finalidad es que todo el mundo pueda generar proyectos y entornos interactivos mediante placas y sensores compatibles con Arduino. Arduino se programa con lenguaje C++ y se necesita el IDE (Integrated Development Environment), que permite escribir el c\u00f3digo. Programar con C++ puede resultar complejo y no es accesible para todos, por eso, Juanjo L\u00f3pez cre\u00f3 ArduinoBlocks , que es un lenguaje de programaci\u00f3n por bloques que se ejecuta en la nube. Los diferentes bloques de programaci\u00f3n sirven para leer y escribir las entradas y salidas de la placa. Podemos registrarnos en la web, para guardar los proyectos, podemos a\u00f1adir informaci\u00f3n a nuestros proyectos y ver proyectos de otros usuarios que hayan decidido compartirlos de forma p\u00fablica. En la Figura 1.2 vemos la portada de la p\u00e1gina web. Figura 1.2. P\u00e1gina principal web ArduinoBlocks \u00bfC\u00f3mo se trabaja con ArduinoBlocks? \u00b6 Para empezar a trabajar con ArduinoBlocks, es necesario registrarse utilizando un correo v\u00e1lido, pues habr\u00e1 que validar la cuenta con ese correo, y crear un nuevo usuario. Debemos acceder al bot\u00f3n \"Iniciar sesi\u00f3n\" para despu\u00e9s, seleccionar la opci\u00f3n de nuevo usuario, tal y como se indica en la Figura 1.3. Figura 1.3. Inicio de sesi\u00f3n en ArduinoBlocks A continuaci\u00f3n, se debe seleccionar \"Empezar un proyecto nuevo\" (Figura 1.4). Figura 1.4. Iniciar un nuevo proyecto Nos aparecen tres opciones: proyecto personal, profesor o alumno, tal y como vemos en la Figura 1.5. Figura 1.5. Opciones de proyecto Si escogemos el proyecto personal s\u00f3lo podremos acceder nosotros, pero despu\u00e9s lo podemos compartir si decidimos hacerlo p\u00fablico. En cambio, si seleccionamos el proyecto profesor, no se comienza un proyecto sino que se crea un c\u00f3digo para que los alumnos puedan inscribirse en el proyecto. De esta forma, el profesor puede supervisar las programaciones de sus estudiantes. Por \u00faltimo, la opci\u00f3n de alumno es para unirnos al proyecto planteado por el profesor. Para aprender mas sobre Usuarios Gestionados basta con acceder a la presentaci\u00f3n del enlace anterior que se adjunta como anexo a este documento. Interfaz de programaci\u00f3n de ArduinoBlocks \u00b6 Una vez hemos escogido la opci\u00f3n de proyecto personal, nos pregunta qu\u00e9 placa estamos utilizando y qu\u00e9 nombre queremos dar a nuestro proyecto. A su vez, podemos a\u00f1adir informaci\u00f3n, como: descripci\u00f3n del proyecto, componentes que necesitamos y otras especificaciones en el apartado de comentarios. En nuestro caso escogeremos: Keyestudio EasyPlug . Toda esta informaci\u00f3n es la que se ve en la Figura 1.6. Figura 1.6. Placa, nombre del proyecto,... Una vez ponemos nombre, y aunque es opcional se recomienda cumplimentar los distintos apartados, y hacemos clic en el bot\u00f3n \u201cNuevo proyecto\u201d entramos en el entorno de programaci\u00f3n para el nuevo proyecto. Nos encontramos con la pantalla de la Figura 1.7 que est\u00e1 autodescrita. Figura 1.7. Entorno de programaci\u00f3n Ya es posible guardar nuestros bloques favoritos de ArduinoBlocks en la mochila y llevarlos siempre con nosotros o usarla para compartir bloques entre nuestros proyectos. En este enlace tienes un video que lo explica de forma gr\u00e1fica. ArduinoBlocks Connector \u00b6 ArduinobBloks genera el c\u00f3digo de Arduino a partir de los bloques. El programa copia y sube nuestra programaci\u00f3n a la placa gracias a la aplicaci\u00f3n ArduinoBlocks Connector. Si no ejecutamos ArduinoBlocks Connector, podremos programar y acceder a la plataforma ArduionBlocks, pero no podremos subir nuestro programa a la placa. As\u00ed pues, es necesario instalarlo en nuestro ordenador, y ejecutarlo cuando hagamos uso de la plataforma. Actualmente, est\u00e1 disponible la versi\u00f3n 5 para estos sistemas operativos: Windows, Ubuntu, MacOS, Chromebook y Raspberry Pi, como vemos en la Figura 1.8. Figura 1.8. Disponibilidad de ArduinoBlocks Connector Sensores \u00b6 Los sensores permiten recabar informaci\u00f3n para que sea procesada por la placa y se accionen ciertas programaciones seg\u00fan nuestra finalidad. Hay varios tipos de sensores. Por ejemplo, si vamos al apartado de \"Sensores\" del men\u00fa de herramientas de ArduinoBlocks, para la placa EasyPlug, existen varios. Algunos de ellos los vemos en la Figura 1.9. Figura 1.9. Algunos tipos de sensores En la Figura 1.10 vemos el aspecto real de algunos sensores que programaremos. Figura 1.10. Sensores Actuadores \u00b6 Los actuadores se accionan cuando la placa procesa la programaci\u00f3n, que puede estar influida por la recogida de datos de alg\u00fan sensor. Hay varios tipos de actuadores. Por ejemplo, si vamos al apartado de \"actuadores\" del men\u00fa de herramientas de ArduinoBlocks, para la placa EasyPlug, existen varios. Algunos de ellos los vemos en la Figura 1.11. Figura 1.11. Algunos tipos de actuadores En la Figura 1.12 vemos el aspecto real de algunos actuadores que programaremos. Figura 1.12. Actuadores","title":"1. Introducci\u00f3n"},{"location":"#1-mis-notas-sobre-programacion-de-la-placa-easy-plug-con-arduinoblocks","text":"Estas notas se dedican a la programaci\u00f3n de la placa de control Ks0240 keyestudio EASY plug V2.0 con ArduinoBlocks a partir de diferentes actividades y/o retos incluyendo informaci\u00f3n b\u00e1sica de los componentes y de programaci\u00f3n de manera progresiva.","title":"1. Mis notas sobre programaci\u00f3n de la placa Easy Plug con ArduinoBlocks"},{"location":"#11-elementos-y-componentes-easy-plug","text":"Easy Plug es una placa donde podemos conectar diferentes sensores y actuadores de forma muy sencilla. Adem\u00e1s, se pueden crear diferentes programas, proyectos y experimentos muy interesantes para ni\u00f1as y ni\u00f1os de los \u00faltimos cursos de Educaci\u00f3n Primaria as\u00ed como, durante la etapa de educaci\u00f3n secundaria. Sus caracter\u00edsticas t\u00e9cnicas principales son: Es compatible con Arduino Uno Cinco puertos digitales (de entrada y salida) Cuatro puertos de entrada anal\u00f3gica Un puerto SPI Un puerto I2C. Sus conectores son pines RJ-11 de cuatro hilos, lo que les hace mucho m\u00e1s f\u00e1ciles para conectarlos y evitar malas conexiones. En la Figura 1.1 vemos una imagen de la placa con r\u00f3tulos descriptivos de la misma. Figura 1.1. Descripci\u00f3n de la placa Easy Plug","title":"1.1. Elementos y componentes Easy Plug"},{"location":"#arduinoblocks-programa-acceso-e-interfaz","text":"Arduino es una plataforma de prototipos de c\u00f3digo abierto, basada en hardware y software flexibles y f\u00e1ciles de utilizar. Su finalidad es que todo el mundo pueda generar proyectos y entornos interactivos mediante placas y sensores compatibles con Arduino. Arduino se programa con lenguaje C++ y se necesita el IDE (Integrated Development Environment), que permite escribir el c\u00f3digo. Programar con C++ puede resultar complejo y no es accesible para todos, por eso, Juanjo L\u00f3pez cre\u00f3 ArduinoBlocks , que es un lenguaje de programaci\u00f3n por bloques que se ejecuta en la nube. Los diferentes bloques de programaci\u00f3n sirven para leer y escribir las entradas y salidas de la placa. Podemos registrarnos en la web, para guardar los proyectos, podemos a\u00f1adir informaci\u00f3n a nuestros proyectos y ver proyectos de otros usuarios que hayan decidido compartirlos de forma p\u00fablica. En la Figura 1.2 vemos la portada de la p\u00e1gina web. Figura 1.2. P\u00e1gina principal web ArduinoBlocks","title":"ArduinoBlocks: programa, acceso e interfaz"},{"location":"#como-se-trabaja-con-arduinoblocks","text":"Para empezar a trabajar con ArduinoBlocks, es necesario registrarse utilizando un correo v\u00e1lido, pues habr\u00e1 que validar la cuenta con ese correo, y crear un nuevo usuario. Debemos acceder al bot\u00f3n \"Iniciar sesi\u00f3n\" para despu\u00e9s, seleccionar la opci\u00f3n de nuevo usuario, tal y como se indica en la Figura 1.3. Figura 1.3. Inicio de sesi\u00f3n en ArduinoBlocks A continuaci\u00f3n, se debe seleccionar \"Empezar un proyecto nuevo\" (Figura 1.4). Figura 1.4. Iniciar un nuevo proyecto Nos aparecen tres opciones: proyecto personal, profesor o alumno, tal y como vemos en la Figura 1.5. Figura 1.5. Opciones de proyecto Si escogemos el proyecto personal s\u00f3lo podremos acceder nosotros, pero despu\u00e9s lo podemos compartir si decidimos hacerlo p\u00fablico. En cambio, si seleccionamos el proyecto profesor, no se comienza un proyecto sino que se crea un c\u00f3digo para que los alumnos puedan inscribirse en el proyecto. De esta forma, el profesor puede supervisar las programaciones de sus estudiantes. Por \u00faltimo, la opci\u00f3n de alumno es para unirnos al proyecto planteado por el profesor. Para aprender mas sobre Usuarios Gestionados basta con acceder a la presentaci\u00f3n del enlace anterior que se adjunta como anexo a este documento.","title":"\u00bfC\u00f3mo se trabaja con ArduinoBlocks?"},{"location":"#interfaz-de-programacion-de-arduinoblocks","text":"Una vez hemos escogido la opci\u00f3n de proyecto personal, nos pregunta qu\u00e9 placa estamos utilizando y qu\u00e9 nombre queremos dar a nuestro proyecto. A su vez, podemos a\u00f1adir informaci\u00f3n, como: descripci\u00f3n del proyecto, componentes que necesitamos y otras especificaciones en el apartado de comentarios. En nuestro caso escogeremos: Keyestudio EasyPlug . Toda esta informaci\u00f3n es la que se ve en la Figura 1.6. Figura 1.6. Placa, nombre del proyecto,... Una vez ponemos nombre, y aunque es opcional se recomienda cumplimentar los distintos apartados, y hacemos clic en el bot\u00f3n \u201cNuevo proyecto\u201d entramos en el entorno de programaci\u00f3n para el nuevo proyecto. Nos encontramos con la pantalla de la Figura 1.7 que est\u00e1 autodescrita. Figura 1.7. Entorno de programaci\u00f3n Ya es posible guardar nuestros bloques favoritos de ArduinoBlocks en la mochila y llevarlos siempre con nosotros o usarla para compartir bloques entre nuestros proyectos. En este enlace tienes un video que lo explica de forma gr\u00e1fica.","title":"Interfaz de programaci\u00f3n de ArduinoBlocks"},{"location":"#arduinoblocks-connector","text":"ArduinobBloks genera el c\u00f3digo de Arduino a partir de los bloques. El programa copia y sube nuestra programaci\u00f3n a la placa gracias a la aplicaci\u00f3n ArduinoBlocks Connector. Si no ejecutamos ArduinoBlocks Connector, podremos programar y acceder a la plataforma ArduionBlocks, pero no podremos subir nuestro programa a la placa. As\u00ed pues, es necesario instalarlo en nuestro ordenador, y ejecutarlo cuando hagamos uso de la plataforma. Actualmente, est\u00e1 disponible la versi\u00f3n 5 para estos sistemas operativos: Windows, Ubuntu, MacOS, Chromebook y Raspberry Pi, como vemos en la Figura 1.8. Figura 1.8. Disponibilidad de ArduinoBlocks Connector","title":"ArduinoBlocks Connector"},{"location":"#sensores","text":"Los sensores permiten recabar informaci\u00f3n para que sea procesada por la placa y se accionen ciertas programaciones seg\u00fan nuestra finalidad. Hay varios tipos de sensores. Por ejemplo, si vamos al apartado de \"Sensores\" del men\u00fa de herramientas de ArduinoBlocks, para la placa EasyPlug, existen varios. Algunos de ellos los vemos en la Figura 1.9. Figura 1.9. Algunos tipos de sensores En la Figura 1.10 vemos el aspecto real de algunos sensores que programaremos. Figura 1.10. Sensores","title":"Sensores"},{"location":"#actuadores","text":"Los actuadores se accionan cuando la placa procesa la programaci\u00f3n, que puede estar influida por la recogida de datos de alg\u00fan sensor. Hay varios tipos de actuadores. Por ejemplo, si vamos al apartado de \"actuadores\" del men\u00fa de herramientas de ArduinoBlocks, para la placa EasyPlug, existen varios. Algunos de ellos los vemos en la Figura 1.11. Figura 1.11. Algunos tipos de actuadores En la Figura 1.12 vemos el aspecto real de algunos actuadores que programaremos. Figura 1.12. Actuadores","title":"Actuadores"},{"location":"4neo/","text":"A37-M\u00f3dulo LED RGB con 4 LEDs Neopixel WS2812 \u00b6 \u00bfQue es Neopixel? Neopixel es una marca creada por Adafruit Industries para referirse a algunos LEDs RGB que son direccionables individualmente, es decir LEDs que cuentan con un circuito l\u00f3gico integrado dentro de si mismos, y este circuito es el que hace posible controlar con un solo pin digital el color de cada LED en una secuencia de LEDs encadenados en tiras, c\u00edrculos o matrices. No todos los LEDs que son direccionables individualmente son Neopixel, solo lo son los basados en alguno de estos controladores: WS2812, WS2811 o SK6812. Cada LED cuenta con los siguientes 4 pines: GND 5V \u2013 Vcc DIN \u2013 Pin que recibe la informaci\u00f3n del color DO \u2013 Pin que entrega la informaci\u00f3n del color El m\u00f3dulo RGB basado en 2812 es una matriz de 2x2 formada por diodos LED 5050 y la circuiter\u00eda necesaria para ser direccionados. Se sincronizan gracias al oscilador interno de alta precisi\u00f3n de que disponen. Cada uno de los LEDs tiene una \u201cdirecci\u00f3n \u00fanica\u201d y es RGB, siendo todo gestionado por un solo cable de datos y el controlador integrado en el mismo elemento. Sus principales caracter\u00edsticas son: Potencia: 100 mW Fuente de luz: LEDs RGB 5050 SMD Modelo de circuito integrado: 4 x WS2812 Niveles de gris: 256 \u00c1ngulo de iluminaci\u00f3n: 180\u00b0 Su aspecto lo vemos en la Figura A37.1. Figura A37.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Visualizaci\u00f3n\" (Figura A37.2) y tiene su propio grupo de bloques. Figura A37.2. Bloques Pr\u00e1ctica A37.1 \u00b6 Vamos a poner en funcionamiento el m\u00f3dulo matriz de 2x2 haciendo un test de colores. Haremos un programa que realice un test de los cuatro diodos LED. El programa lo tenemos en la Figura A37.3. Figura A37.3. Soluci\u00f3n A37.1 Pr\u00e1ctica A37.2 \u00b6 Una pr\u00e1ctica de sem\u00e1foros con la matriz de 2x2. Haremos un sem\u00e1foro sencillo que permanentemente cambie el color entre los tres habituales. El programa lo tenemos en la Figura A37.4. Figura A37.4. Soluci\u00f3n A37.2","title":"A37-M\u00f3dulo con 4 LEDs RGB"},{"location":"4neo/#a37-modulo-led-rgb-con-4-leds-neopixel-ws2812","text":"\u00bfQue es Neopixel? Neopixel es una marca creada por Adafruit Industries para referirse a algunos LEDs RGB que son direccionables individualmente, es decir LEDs que cuentan con un circuito l\u00f3gico integrado dentro de si mismos, y este circuito es el que hace posible controlar con un solo pin digital el color de cada LED en una secuencia de LEDs encadenados en tiras, c\u00edrculos o matrices. No todos los LEDs que son direccionables individualmente son Neopixel, solo lo son los basados en alguno de estos controladores: WS2812, WS2811 o SK6812. Cada LED cuenta con los siguientes 4 pines: GND 5V \u2013 Vcc DIN \u2013 Pin que recibe la informaci\u00f3n del color DO \u2013 Pin que entrega la informaci\u00f3n del color El m\u00f3dulo RGB basado en 2812 es una matriz de 2x2 formada por diodos LED 5050 y la circuiter\u00eda necesaria para ser direccionados. Se sincronizan gracias al oscilador interno de alta precisi\u00f3n de que disponen. Cada uno de los LEDs tiene una \u201cdirecci\u00f3n \u00fanica\u201d y es RGB, siendo todo gestionado por un solo cable de datos y el controlador integrado en el mismo elemento. Sus principales caracter\u00edsticas son: Potencia: 100 mW Fuente de luz: LEDs RGB 5050 SMD Modelo de circuito integrado: 4 x WS2812 Niveles de gris: 256 \u00c1ngulo de iluminaci\u00f3n: 180\u00b0 Su aspecto lo vemos en la Figura A37.1. Figura A37.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Visualizaci\u00f3n\" (Figura A37.2) y tiene su propio grupo de bloques. Figura A37.2. Bloques","title":"A37-M\u00f3dulo LED RGB con 4 LEDs Neopixel WS2812"},{"location":"4neo/#practica-a371","text":"Vamos a poner en funcionamiento el m\u00f3dulo matriz de 2x2 haciendo un test de colores. Haremos un programa que realice un test de los cuatro diodos LED. El programa lo tenemos en la Figura A37.3. Figura A37.3. Soluci\u00f3n A37.1","title":"Pr\u00e1ctica A37.1"},{"location":"4neo/#practica-a372","text":"Una pr\u00e1ctica de sem\u00e1foros con la matriz de 2x2. Haremos un sem\u00e1foro sencillo que permanentemente cambie el color entre los tres habituales. El programa lo tenemos en la Figura A37.4. Figura A37.4. Soluci\u00f3n A37.2","title":"Pr\u00e1ctica A37.2"},{"location":"LDR/","text":"A05-Sensor LDR \u00b6 En esta pr\u00e1ctica aprenderemos a programar el sensor de instensidad de luz o c\u00f3mo se llama en ArduinoBlocks: 'Nivel de LUZ (LDR)'. Este sensor es necesario conectarlo a un puerto anal\u00f3gico. El sensor 'Nivel de LUZ (LDR)', tambi\u00e9n llamado fotoc\u00e9lula, es muy com\u00fan en nuestra vida cotidiana. Por ejemplo, cuando se encienden las farolas por la noche, las luces solares de jard\u00edn, los detectores de dinero, ... Es un sensor anal\u00f3gico que obtiene valores de tensi\u00f3n entre 0 y 5V y nos los convierte en num\u00e9ricos entre 0 y 1023. El sensor tiene el aspecto que vemos en la Figura A05.1. Figura A05.1. Aspecto sensor LDR En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\", como vemos en la Figura A05.2. Figura A05.2. Bloque sensor LDR Pr\u00e1ctica A05.1 \u00b6 Antes de empezar la programaci\u00f3n, necesitamos conocer qu\u00e9 valores marca el sensor en el lugar en el que trabajamos. Es decir, no podemos programar sin conocer el % de intensidad de luz que tenemos en nuestro entorno. Una vez obtenido este valor, podremos empezar las programaciones m\u00e1s complejas. As\u00ed pues, lo primero que haremos es un programa para: Ver en la consola el % de intensidad de luz cada 3 segundos. En la Figura A05.3 vemos el programa. Figura A05.3. Soluci\u00f3n A05.1 Pr\u00e1ctica A05.2 \u00b6 Para realizar esta segunda pr\u00e1ctica, necesitamos conocer el bloque de programaci\u00f3n que nos permite igualar o comparar si un n\u00famero es mayor o menor que otro. Adem\u00e1s, utilizaremos el bloque que nos permite escribir n\u00fameros. En la Figura A05.4 vemos los diferentes bloques de programaci\u00f3n. Figura A05.4. Bloques Si la intensidad de luz es superior a un valor X (tomar como referencia el medido en la pr\u00e1ctica anterior) que en la consola aparezca \"Claro\". En la Figura A05.5 vemos el programa. Figura A05.5. Soluci\u00f3n A05.2 Pr\u00e1ctica A05.3 \u00b6 Si la intensidad de luz es superior a un valor X, en nuestro caso 65%, que la consola escriba \"Claro\". Sin embargo, si es inferior al valor anterior, que la consola escriba \"Oscuro\". Hay dos formas de programarlo, la primera necesitas especificar qu\u00e9 condici\u00f3n debe suceder para que la consola escriba \"Oscuro\". En la Figura A05.6 vemos el programa. Figura A05.6. Soluci\u00f3n A05.3 En la segunda forma se entiende que todo lo que no sea la primera condici\u00f3n ser\u00e1 la segunda. En la Figura A05.7 vemos el programa. Figura A05.7. Soluci\u00f3n A05.3 Hemos cambiado el bloque \u201csi \u2026 hacer\u201d por el bloque \u201csi \u2026 hacer \u2026 sino\u201d Pr\u00e1ctica A05.4 \u00b6 En esta pr\u00e1ctica volveremos a trabajar con las variables. Las variables son elementos comunes en programaci\u00f3n. Cuando creamos una variable estamos dando un nombre a un dato o una lectura. Por ejemplo, cuando el sensor de intensidad de la luz detecta el porcentaje de luz de la habitaci\u00f3n, toda la medida de los diferentes valores podemos agruparlos con la variable nombrada \"Intensidad de luz\". No es obligatorio utilizar variables, pero es una forma mucho m\u00e1s c\u00f3moda y comprensible de crear nuestros programas. Para crear una nueva variable, debemos ir al apartado de variables y establecer una del tipo que necesitemos. Es decir, asignaremos un nombre a un conjunto de valores comunes. Cuando no tenemos ninguna variable creada en nuestro programa el aspecto que muestra el men\u00fa 'Variables' lo vemos en la Figura A05.8. Figura A05.8. Men\u00fa variables En la Figura A05.9 vemos como cambia el men\u00fa cuando creamos una de tipo n\u00famero llamada \u201cIntensidad de luz\u201d. Figura A05.9. Men\u00fa variables con una variable creada Si necesitamos renombrar o eliminar una variable debemos mostrar el desplegable del bloque \u201cEstablecer valor\u201d y escoger la opci\u00f3n que corresponda a nuestro caso (Figura A05.10). Para poder hacer esto debemos tener el bloque en la zona de programa. Figura A05.10. Renombrar o borrar variable Es necesario establecer el valor de la variable en el bucle, y asociarla a un sensor que pueda agruparnos los valores. Lo habitual y recomendable en programaci\u00f3n es definir e inicializar las variables a \u201c0\u201d o a un valor que nos interesa en el bloque \u201cInicializar\u201d y en \u201cBucle\u201d trabajar con ellas, tal y como vemos en la Figura A05.11. Figura A05.11. Inicializar y asignar valor a variable Repetiremos los mismos ejercicios que las pr\u00e1cticas anteriores pero utilizando la variable en lugar del bloque del sensor. Env\u00eda a la consola el % de intensidad de luz cada 3 segundos. En la consola debe aparecer escrito de la siguiente manera: Intensidad luz: XX,XX. Para ello, vamos a utilizar un nuevo bloque el que encontramos en el men\u00fa \"Texto\" llamado 'Crear texto con que vemos en la Figura A05.12, donde tambi\u00e9n vemos el programa y el resultado en la Consola. Figura A05.12. Soluci\u00f3n A05.4 Pr\u00e1ctica A05.5 \u00b6 En este \u00faltimo proyecto utilizando el sensor de luz, imitaremos qu\u00e9 ocurre cuando por la noche las farolas de la calle se encienden. Por tanto, utilizaremos un LED y el sensor LDR. Ejemplifica lo que sucede por la noche con las farolas de la calle. Es decir, cuando la intensidad de la luz sea inferior o igual a un 5%, que el LED se encienda. Por el contrario, cuando sea superior al 5%, el LED se apaga. El programa lo vemos en la Figura A05.13. Figura A05.13. Soluci\u00f3n A05.5","title":"A05-Sensor LDR"},{"location":"LDR/#a05-sensor-ldr","text":"En esta pr\u00e1ctica aprenderemos a programar el sensor de instensidad de luz o c\u00f3mo se llama en ArduinoBlocks: 'Nivel de LUZ (LDR)'. Este sensor es necesario conectarlo a un puerto anal\u00f3gico. El sensor 'Nivel de LUZ (LDR)', tambi\u00e9n llamado fotoc\u00e9lula, es muy com\u00fan en nuestra vida cotidiana. Por ejemplo, cuando se encienden las farolas por la noche, las luces solares de jard\u00edn, los detectores de dinero, ... Es un sensor anal\u00f3gico que obtiene valores de tensi\u00f3n entre 0 y 5V y nos los convierte en num\u00e9ricos entre 0 y 1023. El sensor tiene el aspecto que vemos en la Figura A05.1. Figura A05.1. Aspecto sensor LDR En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\", como vemos en la Figura A05.2. Figura A05.2. Bloque sensor LDR","title":"A05-Sensor LDR"},{"location":"LDR/#practica-a051","text":"Antes de empezar la programaci\u00f3n, necesitamos conocer qu\u00e9 valores marca el sensor en el lugar en el que trabajamos. Es decir, no podemos programar sin conocer el % de intensidad de luz que tenemos en nuestro entorno. Una vez obtenido este valor, podremos empezar las programaciones m\u00e1s complejas. As\u00ed pues, lo primero que haremos es un programa para: Ver en la consola el % de intensidad de luz cada 3 segundos. En la Figura A05.3 vemos el programa. Figura A05.3. Soluci\u00f3n A05.1","title":"Pr\u00e1ctica A05.1"},{"location":"LDR/#practica-a052","text":"Para realizar esta segunda pr\u00e1ctica, necesitamos conocer el bloque de programaci\u00f3n que nos permite igualar o comparar si un n\u00famero es mayor o menor que otro. Adem\u00e1s, utilizaremos el bloque que nos permite escribir n\u00fameros. En la Figura A05.4 vemos los diferentes bloques de programaci\u00f3n. Figura A05.4. Bloques Si la intensidad de luz es superior a un valor X (tomar como referencia el medido en la pr\u00e1ctica anterior) que en la consola aparezca \"Claro\". En la Figura A05.5 vemos el programa. Figura A05.5. Soluci\u00f3n A05.2","title":"Pr\u00e1ctica A05.2"},{"location":"LDR/#practica-a053","text":"Si la intensidad de luz es superior a un valor X, en nuestro caso 65%, que la consola escriba \"Claro\". Sin embargo, si es inferior al valor anterior, que la consola escriba \"Oscuro\". Hay dos formas de programarlo, la primera necesitas especificar qu\u00e9 condici\u00f3n debe suceder para que la consola escriba \"Oscuro\". En la Figura A05.6 vemos el programa. Figura A05.6. Soluci\u00f3n A05.3 En la segunda forma se entiende que todo lo que no sea la primera condici\u00f3n ser\u00e1 la segunda. En la Figura A05.7 vemos el programa. Figura A05.7. Soluci\u00f3n A05.3 Hemos cambiado el bloque \u201csi \u2026 hacer\u201d por el bloque \u201csi \u2026 hacer \u2026 sino\u201d","title":"Pr\u00e1ctica A05.3"},{"location":"LDR/#practica-a054","text":"En esta pr\u00e1ctica volveremos a trabajar con las variables. Las variables son elementos comunes en programaci\u00f3n. Cuando creamos una variable estamos dando un nombre a un dato o una lectura. Por ejemplo, cuando el sensor de intensidad de la luz detecta el porcentaje de luz de la habitaci\u00f3n, toda la medida de los diferentes valores podemos agruparlos con la variable nombrada \"Intensidad de luz\". No es obligatorio utilizar variables, pero es una forma mucho m\u00e1s c\u00f3moda y comprensible de crear nuestros programas. Para crear una nueva variable, debemos ir al apartado de variables y establecer una del tipo que necesitemos. Es decir, asignaremos un nombre a un conjunto de valores comunes. Cuando no tenemos ninguna variable creada en nuestro programa el aspecto que muestra el men\u00fa 'Variables' lo vemos en la Figura A05.8. Figura A05.8. Men\u00fa variables En la Figura A05.9 vemos como cambia el men\u00fa cuando creamos una de tipo n\u00famero llamada \u201cIntensidad de luz\u201d. Figura A05.9. Men\u00fa variables con una variable creada Si necesitamos renombrar o eliminar una variable debemos mostrar el desplegable del bloque \u201cEstablecer valor\u201d y escoger la opci\u00f3n que corresponda a nuestro caso (Figura A05.10). Para poder hacer esto debemos tener el bloque en la zona de programa. Figura A05.10. Renombrar o borrar variable Es necesario establecer el valor de la variable en el bucle, y asociarla a un sensor que pueda agruparnos los valores. Lo habitual y recomendable en programaci\u00f3n es definir e inicializar las variables a \u201c0\u201d o a un valor que nos interesa en el bloque \u201cInicializar\u201d y en \u201cBucle\u201d trabajar con ellas, tal y como vemos en la Figura A05.11. Figura A05.11. Inicializar y asignar valor a variable Repetiremos los mismos ejercicios que las pr\u00e1cticas anteriores pero utilizando la variable en lugar del bloque del sensor. Env\u00eda a la consola el % de intensidad de luz cada 3 segundos. En la consola debe aparecer escrito de la siguiente manera: Intensidad luz: XX,XX. Para ello, vamos a utilizar un nuevo bloque el que encontramos en el men\u00fa \"Texto\" llamado 'Crear texto con que vemos en la Figura A05.12, donde tambi\u00e9n vemos el programa y el resultado en la Consola. Figura A05.12. Soluci\u00f3n A05.4","title":"Pr\u00e1ctica A05.4"},{"location":"LDR/#practica-a055","text":"En este \u00faltimo proyecto utilizando el sensor de luz, imitaremos qu\u00e9 ocurre cuando por la noche las farolas de la calle se encienden. Por tanto, utilizaremos un LED y el sensor LDR. Ejemplifica lo que sucede por la noche con las farolas de la calle. Es decir, cuando la intensidad de la luz sea inferior o igual a un 5%, que el LED se encienda. Por el contrario, cuando sea superior al 5%, el LED se apaga. El programa lo vemos en la Figura A05.13. Figura A05.13. Soluci\u00f3n A05.5","title":"Pr\u00e1ctica A05.5"},{"location":"LEDPulsador/","text":"A03 - Control de encendido y apagado de un LED con un pulsador \u00b6 Continuando con el uso de LED, en las siguientes pr\u00e1cticas lo combinaremos con dos pulsadores: el t\u00e1ctil y el pulsador normal que vemos en las Figuras A03.1 y A03.2 respectivamente. Figura A03.1. Pulsador El pulsador es un sensor digital, que tiene dos estados. Cuando se presiona el bot\u00f3n, emite una se\u00f1al de nivel alto, es decir, 5V. En cambio, cuando se suelta el bot\u00f3n, emite una se\u00f1al de nivel bajo: 0V. Figura A03.2. Pulsador t\u00e1ctil El pulsador t\u00e1ctil es un sensor t\u00e1ctil, tal y como explica su nombre puede \"sentir\" el tacto de forma muy sensible y funciona de la misma forma que el pulsador de bot\u00f3n. Los dos pulsadores son sensores, por tanto, los encontraremos en el apartado \"Sensores\". En el momento de la programaci\u00f3n es muy importante tener en cuenta a qu\u00e9 puerto los hemos conectado. Siempre se conectan a los puertos digitales, pero es necesario programar el n\u00famero correcto. En la Figura A03.3 vemos los bloques de ambos pulsadores. Figura A03.3. Bloques pulsadores Tambi\u00e9n empezaremos a hacer uso de las funciones de \"L\u00f3gica\", como la condicional: \"si\u2026 hacer\". Este bloque de programaci\u00f3n es uno de los pilares fundamentales en el mundo de la programaci\u00f3n, puesto que permite evaluar estados, y seg\u00fan la condici\u00f3n, programar acciones, es decir tomar decisiones. En la Figura A03.4 vemos este bloque. Figura A03.4. Bloque si\u2026 hacer En el apartado de condiciones se pueden introducir factores como: estado de los sensores, comparaciones, igualdades, operaciones matem\u00e1ticas. En cambio, en el apartado de acciones, podemos programar: encender un LED, enviar mensajes a la consola, escribir algo en alguna pantalla externa, etc. Tambi\u00e9n, se puede ampliar el bloque con m\u00e1s condicionales haciendo clic en el s\u00edmbolo \u201c+\u201d y quitarlos con el signo \u201c-\u201d, como vemos en la Figura A03.5. Figura A03.5. Ampliar o reducir el bloque si\u2026 hacer Pr\u00e1ctica A03.1 \u00b6 \u2022 Si hacemos clic en el pulsador el LED se enciende durante 2 segundos. El programa lo vemos en la Figura A03.6. Figura A03.6. Programa pulsador mas LED Pr\u00e1ctica A03.2 \u00b6 \u2022 Si hacemos clic en el pulsador t\u00e1ctil el LED se enciende durante 2 segundos. El programa lo vemos en la Figura A03.7. Figura A03.7. Programa pulsador t\u00e1ctil mas LED Pr\u00e1ctica A03.3 \u00b6 \u2022 Si hacemos clic en el pulsador t\u00e1ctil se enciende el LED. Sin embargo, si hacemos clic en el otro pulsador, se apaga. El programa lo vemos en la Figura A03.8. Figura A03.8. Programa con dos pulsadores mas LED","title":"A03-Control LED con un pulsador"},{"location":"LEDPulsador/#a03-control-de-encendido-y-apagado-de-un-led-con-un-pulsador","text":"Continuando con el uso de LED, en las siguientes pr\u00e1cticas lo combinaremos con dos pulsadores: el t\u00e1ctil y el pulsador normal que vemos en las Figuras A03.1 y A03.2 respectivamente. Figura A03.1. Pulsador El pulsador es un sensor digital, que tiene dos estados. Cuando se presiona el bot\u00f3n, emite una se\u00f1al de nivel alto, es decir, 5V. En cambio, cuando se suelta el bot\u00f3n, emite una se\u00f1al de nivel bajo: 0V. Figura A03.2. Pulsador t\u00e1ctil El pulsador t\u00e1ctil es un sensor t\u00e1ctil, tal y como explica su nombre puede \"sentir\" el tacto de forma muy sensible y funciona de la misma forma que el pulsador de bot\u00f3n. Los dos pulsadores son sensores, por tanto, los encontraremos en el apartado \"Sensores\". En el momento de la programaci\u00f3n es muy importante tener en cuenta a qu\u00e9 puerto los hemos conectado. Siempre se conectan a los puertos digitales, pero es necesario programar el n\u00famero correcto. En la Figura A03.3 vemos los bloques de ambos pulsadores. Figura A03.3. Bloques pulsadores Tambi\u00e9n empezaremos a hacer uso de las funciones de \"L\u00f3gica\", como la condicional: \"si\u2026 hacer\". Este bloque de programaci\u00f3n es uno de los pilares fundamentales en el mundo de la programaci\u00f3n, puesto que permite evaluar estados, y seg\u00fan la condici\u00f3n, programar acciones, es decir tomar decisiones. En la Figura A03.4 vemos este bloque. Figura A03.4. Bloque si\u2026 hacer En el apartado de condiciones se pueden introducir factores como: estado de los sensores, comparaciones, igualdades, operaciones matem\u00e1ticas. En cambio, en el apartado de acciones, podemos programar: encender un LED, enviar mensajes a la consola, escribir algo en alguna pantalla externa, etc. Tambi\u00e9n, se puede ampliar el bloque con m\u00e1s condicionales haciendo clic en el s\u00edmbolo \u201c+\u201d y quitarlos con el signo \u201c-\u201d, como vemos en la Figura A03.5. Figura A03.5. Ampliar o reducir el bloque si\u2026 hacer","title":"A03 - Control de encendido y apagado de un LED con un pulsador"},{"location":"LEDPulsador/#practica-a031","text":"\u2022 Si hacemos clic en el pulsador el LED se enciende durante 2 segundos. El programa lo vemos en la Figura A03.6. Figura A03.6. Programa pulsador mas LED","title":"Pr\u00e1ctica A03.1"},{"location":"LEDPulsador/#practica-a032","text":"\u2022 Si hacemos clic en el pulsador t\u00e1ctil el LED se enciende durante 2 segundos. El programa lo vemos en la Figura A03.7. Figura A03.7. Programa pulsador t\u00e1ctil mas LED","title":"Pr\u00e1ctica A03.2"},{"location":"LEDPulsador/#practica-a033","text":"\u2022 Si hacemos clic en el pulsador t\u00e1ctil se enciende el LED. Sin embargo, si hacemos clic en el otro pulsador, se apaga. El programa lo vemos en la Figura A03.8. Figura A03.8. Programa con dos pulsadores mas LED","title":"Pr\u00e1ctica A03.3"},{"location":"R01/","text":"Saludo por consola si se recibe desde el PC \"H\" \u00b6 Enunciado: Prueba de comunicaci\u00f3n entre nuestra placa Easy Plug y el ordenador a trav\u00e9s de la consola serie. Implementar un programa que establezca las condiciones para que al recibir la placa EP el car\u00e1cter 'H' enviado desde la consola nos responda con un mensaje en la misma consola. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R01 Soluci\u00f3n para importar .abp: Enlace al programa EP-R01.abp","title":"R01-Saludo por consola"},{"location":"R01/#saludo-por-consola-si-se-recibe-desde-el-pc-h","text":"Enunciado: Prueba de comunicaci\u00f3n entre nuestra placa Easy Plug y el ordenador a trav\u00e9s de la consola serie. Implementar un programa que establezca las condiciones para que al recibir la placa EP el car\u00e1cter 'H' enviado desde la consola nos responda con un mensaje en la misma consola. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R01 Soluci\u00f3n para importar .abp: Enlace al programa EP-R01.abp","title":"Saludo por consola si se recibe desde el PC \"H\""},{"location":"R02/","text":"R02-Quien parpadea \u00b6 Enunciado: Un LED estar\u00e1 encendido durante un segundo y luego se apagar\u00e1 durante un segundo, como un ojo que parpadea con ese intervalo. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R02 Soluci\u00f3n para importar .abp: Enlace al programa EP-R02.abp","title":"R02-Quien parpadea"},{"location":"R02/#r02-quien-parpadea","text":"Enunciado: Un LED estar\u00e1 encendido durante un segundo y luego se apagar\u00e1 durante un segundo, como un ojo que parpadea con ese intervalo. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R02 Soluci\u00f3n para importar .abp: Enlace al programa EP-R02.abp","title":"R02-Quien parpadea"},{"location":"R03/","text":"R02-Respiraci\u00f3n \u00b6 Enunciado: Un LED aumenta su luminosidad poco a poco (inspira) con esperas de 10ms entre cada cambio, se queda totalmente encendido durante un segundo y luego se aten\u00faa gradualmente (expira) de la misma forma quedando totalmente apagado un segundo y comienza la secuencia de nuevo. Es una simulaci\u00f3n que hace parecer que el LED est\u00e1 respirando. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R03 Soluci\u00f3n para importar .abp: Enlace al programa EP-R03.abp","title":"R03-Respiraci\u00f3n"},{"location":"R03/#r02-respiracion","text":"Enunciado: Un LED aumenta su luminosidad poco a poco (inspira) con esperas de 10ms entre cada cambio, se queda totalmente encendido durante un segundo y luego se aten\u00faa gradualmente (expira) de la misma forma quedando totalmente apagado un segundo y comienza la secuencia de nuevo. Es una simulaci\u00f3n que hace parecer que el LED est\u00e1 respirando. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R03 Soluci\u00f3n para importar .abp: Enlace al programa EP-R03.abp","title":"R02-Respiraci\u00f3n"},{"location":"R04/","text":"R04-Luz que fluye \u00b6 Enunciado: Aprovechando lo visto en el reto 3 vamos a hacer que esa secuencia se reproduzca en tres LEDs, es decir, un LED aumenta su luminosidad poco a poco con esperas de 5ms entre cada cambio, se queda totalmente encendido durante 100ms y luego se aten\u00faa gradualmente de la misma forma quedando totalmente apagado durante 50ms, ahora comienza un segundo LED a hacer lo mismo y cuando finalice lo har\u00e1 un tercero y al finalizar este empieza otra ver el primero. Hacemos como si la luz fluyese de un LED a otro. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 3 - Cable Easy Plug 3 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R04 Soluci\u00f3n para importar .abp: Enlace al programa EP-R04.abp","title":"R04-Luz que fluye"},{"location":"R04/#r04-luz-que-fluye","text":"Enunciado: Aprovechando lo visto en el reto 3 vamos a hacer que esa secuencia se reproduzca en tres LEDs, es decir, un LED aumenta su luminosidad poco a poco con esperas de 5ms entre cada cambio, se queda totalmente encendido durante 100ms y luego se aten\u00faa gradualmente de la misma forma quedando totalmente apagado durante 50ms, ahora comienza un segundo LED a hacer lo mismo y cuando finalice lo har\u00e1 un tercero y al finalizar este empieza otra ver el primero. Hacemos como si la luz fluyese de un LED a otro. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 3 - Cable Easy Plug 3 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R04 Soluci\u00f3n para importar .abp: Enlace al programa EP-R04.abp","title":"R04-Luz que fluye"},{"location":"R05/","text":"R04-Luz que fluye \u00b6 Enunciado: Vamos a hacer que cuando accionemos un pulsador se reproduzca un sonido en el zumbador activo que estar\u00e1 activo durante 750ms y sin sonar durante 300ms. Haremos que el sonido se repita cinco veces cada vez que pulsemos. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 2 - Cable Easy Plug 1 - M\u00f3dulo buzzer activo ( Ks0102 ) 1 - M\u00f3dulo pulsador ( Ks0112 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R05 Soluci\u00f3n para importar .abp: Enlace al programa EP-R05.abp","title":"R05-Timbre"},{"location":"R05/#r04-luz-que-fluye","text":"Enunciado: Vamos a hacer que cuando accionemos un pulsador se reproduzca un sonido en el zumbador activo que estar\u00e1 activo durante 750ms y sin sonar durante 300ms. Haremos que el sonido se repita cinco veces cada vez que pulsemos. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 2 - Cable Easy Plug 1 - M\u00f3dulo buzzer activo ( Ks0102 ) 1 - M\u00f3dulo pulsador ( Ks0112 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R05 Soluci\u00f3n para importar .abp: Enlace al programa EP-R05.abp","title":"R04-Luz que fluye"},{"location":"R06/","text":"R06-Quien canta \u00b6 Enunciado: Haremos que el zumbador reproduzca una conocida melod\u00eda cada 3 segundos para ver si es reconocida. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - M\u00f3dulo buzzer pasivo ( Ks0103 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R06 Soluci\u00f3n para importar .abp: Enlace al programa EP-R06.abp","title":"R06-Quien canta"},{"location":"R06/#r06-quien-canta","text":"Enunciado: Haremos que el zumbador reproduzca una conocida melod\u00eda cada 3 segundos para ver si es reconocida. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - M\u00f3dulo buzzer pasivo ( Ks0103 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R06 Soluci\u00f3n para importar .abp: Enlace al programa EP-R06.abp","title":"R06-Quien canta"},{"location":"R07/","text":"R07-Term\u00f3metro al rev\u00e9s \u00b6 Enunciado: Vamos a medir la temperatura con el \"Sensor anal\u00f3gico de temperatura\" que en realidad est\u00e1 basado en un dispositivo denominado termistor. Ya en el propio bloque de programaci\u00f3n pone unas siglas, NTC que significan 'Coeficiente Negativo de Temperatura' y en la pr\u00e1ctica lo que ocurre es que el termistor disminuye su resistencia cuando aumenta la temperatura por lo que el valor anal\u00f3gico que entrega tiene ese comportamiento. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - Sensor anal\u00f3gico de temperatura ( Ks0104 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R07 Soluci\u00f3n para importar .abp: Enlace al programa EP-R07.abp","title":"R07-Term\u00f3metro al rev\u00e9s"},{"location":"R07/#r07-termometro-al-reves","text":"Enunciado: Vamos a medir la temperatura con el \"Sensor anal\u00f3gico de temperatura\" que en realidad est\u00e1 basado en un dispositivo denominado termistor. Ya en el propio bloque de programaci\u00f3n pone unas siglas, NTC que significan 'Coeficiente Negativo de Temperatura' y en la pr\u00e1ctica lo que ocurre es que el termistor disminuye su resistencia cuando aumenta la temperatura por lo que el valor anal\u00f3gico que entrega tiene ese comportamiento. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - Sensor anal\u00f3gico de temperatura ( Ks0104 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R07 Soluci\u00f3n para importar .abp: Enlace al programa EP-R07.abp","title":"R07-Term\u00f3metro al rev\u00e9s"},{"location":"R08/","text":"R08-Al aplaudir se enciende una luz \u00b6 Enunciado: Se trata de hacer una l\u00e1mpara controlada por sonido de forma que cuando el sonido ambiente supere un determinado nivel esta se encienda y si no lo supera que permanezca apagada. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 2 - Cable Easy Plug 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) 1 - Sensor anal\u00f3gico de sonido ( Ks0105 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R08 Soluci\u00f3n para importar .abp: Enlace al programa EP-R08.abp","title":"R08-Aplaudir = luz"},{"location":"R08/#r08-al-aplaudir-se-enciende-una-luz","text":"Enunciado: Se trata de hacer una l\u00e1mpara controlada por sonido de forma que cuando el sonido ambiente supere un determinado nivel esta se encienda y si no lo supera que permanezca apagada. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 2 - Cable Easy Plug 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) 1 - Sensor anal\u00f3gico de sonido ( Ks0105 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R08 Soluci\u00f3n para importar .abp: Enlace al programa EP-R08.abp","title":"R08-Al aplaudir se enciende una luz"},{"location":"R09/","text":"R09-Farola autom\u00e1tica \u00b6 Enunciado: Se trata de hacer la imitaci\u00f3n del encendido autom\u00e1tico de una farola seg\u00fan el nivel de luz solar existente. Nos ayudaremos del monitor serie para saber las condiciones de iluminaci\u00f3n del lugar donde vamos a probar el reto. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 2 - Cable Easy Plug 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) 1 - Fotoc\u00e9lula o LDR ( Ks0106 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R09 Soluci\u00f3n para importar .abp: Enlace al programa EP-R09.abp","title":"R09-Farola autom\u00e1tica"},{"location":"R09/#r09-farola-automatica","text":"Enunciado: Se trata de hacer la imitaci\u00f3n del encendido autom\u00e1tico de una farola seg\u00fan el nivel de luz solar existente. Nos ayudaremos del monitor serie para saber las condiciones de iluminaci\u00f3n del lugar donde vamos a probar el reto. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 2 - Cable Easy Plug 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) 1 - Fotoc\u00e9lula o LDR ( Ks0106 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R09 Soluci\u00f3n para importar .abp: Enlace al programa EP-R09.abp","title":"R09-Farola autom\u00e1tica"},{"location":"R10/","text":"R10-Escape de agua \u00b6 Enunciado: Se trata de crear una alarma \u00f3ptico-ac\u00fastica que nos informe que hay agua en el suelo donde est\u00e1 colocada la lavadora, el lavavajillas o cualquier elemento que nosotros necesitemos. Nos ayudamos de la consola serie para saber los valores que env\u00eda el sensor cuando est\u00e1 seco (deber\u00eda ser 0) o cuando est\u00e1 en contacto con agua. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 3 - Cable Easy Plug 1 - M\u00f3dulo buzzer activo ( Ks0102 ) 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) 1 - Sensor de agua ( Ks0107 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R10 Soluci\u00f3n para importar .abp: Enlace al programa EP-R10.abp","title":"R10-Escape de agua"},{"location":"R10/#r10-escape-de-agua","text":"Enunciado: Se trata de crear una alarma \u00f3ptico-ac\u00fastica que nos informe que hay agua en el suelo donde est\u00e1 colocada la lavadora, el lavavajillas o cualquier elemento que nosotros necesitemos. Nos ayudamos de la consola serie para saber los valores que env\u00eda el sensor cuando est\u00e1 seco (deber\u00eda ser 0) o cuando est\u00e1 en contacto con agua. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 3 - Cable Easy Plug 1 - M\u00f3dulo buzzer activo ( Ks0102 ) 1 - M\u00f3dulo con diodo LED blanco ( Ks0100 ) 1 - Sensor de agua ( Ks0107 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R10 Soluci\u00f3n para importar .abp: Enlace al programa EP-R10.abp","title":"R10-Escape de agua"},{"location":"R11/","text":"R11-La planta sedienta \u00b6 Enunciado: Crear un programa que nos muestre en la consola serie los mensajes indicados para las condiciones que se exponen a continuaci\u00f3n. Si la humedad del suelo es \u2264250 el mensaje ser\u00e1: \"Suelo seco, necesito que me riegues por favor\" y sonar\u00e1 el zumbador con un pitido largo. Si la humedad est\u00e1 entre 251 y 400 el mensaje ser\u00e1: \"Suelo h\u00famedo, no necesito agua gracias\". Si la humedad es superior a 400 el mensaje ser\u00e1: \"Estoy encharcada, no mas agua por favor\" y sonar\u00e1 el zumbador con un sonido diferente con un pitido corto. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 2 - Cable Easy Plug 1 - M\u00f3dulo buzzer activo ( Ks0102 ) 1 - Sensor de humedad del suelo ( Ks0108 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R11 Soluci\u00f3n para importar .abp: Enlace al programa EP-R11.abp","title":"R11-La planta sedienta"},{"location":"R11/#r11-la-planta-sedienta","text":"Enunciado: Crear un programa que nos muestre en la consola serie los mensajes indicados para las condiciones que se exponen a continuaci\u00f3n. Si la humedad del suelo es \u2264250 el mensaje ser\u00e1: \"Suelo seco, necesito que me riegues por favor\" y sonar\u00e1 el zumbador con un pitido largo. Si la humedad est\u00e1 entre 251 y 400 el mensaje ser\u00e1: \"Suelo h\u00famedo, no necesito agua gracias\". Si la humedad es superior a 400 el mensaje ser\u00e1: \"Estoy encharcada, no mas agua por favor\" y sonar\u00e1 el zumbador con un sonido diferente con un pitido corto. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 2 - Cable Easy Plug 1 - M\u00f3dulo buzzer activo ( Ks0102 ) 1 - Sensor de humedad del suelo ( Ks0108 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R11 Soluci\u00f3n para importar .abp: Enlace al programa EP-R11.abp","title":"R11-La planta sedienta"},{"location":"R12/","text":"R12-Veo datos \u00b6 Enunciado: En esta ocasi\u00f3n vamos a mostrar de forma gr\u00e1fica en el Serial Plotter el valor anal\u00f3gico le\u00eddo del potenci\u00f3metro. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - M\u00f3dulo potenci\u00f3metro rotativo ( Ks0109 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R12 Soluci\u00f3n para importar .abp: Enlace al programa EP-R12.abp","title":"R12-Veo datos"},{"location":"R12/#r12-veo-datos","text":"Enunciado: En esta ocasi\u00f3n vamos a mostrar de forma gr\u00e1fica en el Serial Plotter el valor anal\u00f3gico le\u00eddo del potenci\u00f3metro. Material necesario: Todo corresponde al EASY PLUG Starter Kit KS0158 1 - Placa Easy Plug ( Ks0240 ) 1 - Cable USB (Incluido con la placa) 1 - Cable Easy Plug 1 - M\u00f3dulo potenci\u00f3metro rotativo ( Ks0109 ) Soluci\u00f3n gr\u00e1fica: Enlace para importar desde ArduinoBlocks: Enlace al programa en ArduinoBlocks de EP-R12 Soluci\u00f3n para importar .abp: Enlace al programa EP-R12.abp","title":"R12-Veo datos"},{"location":"Reto_propuesto/","text":"Reto propuesto \u00b6 Se propone crear un circuito que utilice diferentes elementos del EASY PLUG Starter Kit KS0158 , e incluso de otros elementos de expansi\u00f3n del kit y crear el programa que trabaje con los mismos. Tem\u00e1tica: libre N\u00famero m\u00ednimo de elementos: 5 Debe mezclar dispositivos digitales y anal\u00f3gicos Utilizar\u00e1 diferentes sensores y al menos un actuador El reto ser\u00e1 documentado con el mismo estilo que se han documentado los retos resueltos utilizando para ello los medios que se estimen convenientes Todos los trabajos sobre el reto propuesto quedar\u00e1n bajo las mismas licencias que esta web","title":"Reto propuesto"},{"location":"Reto_propuesto/#reto-propuesto","text":"Se propone crear un circuito que utilice diferentes elementos del EASY PLUG Starter Kit KS0158 , e incluso de otros elementos de expansi\u00f3n del kit y crear el programa que trabaje con los mismos. Tem\u00e1tica: libre N\u00famero m\u00ednimo de elementos: 5 Debe mezclar dispositivos digitales y anal\u00f3gicos Utilizar\u00e1 diferentes sensores y al menos un actuador El reto ser\u00e1 documentado con el mismo estilo que se han documentado los retos resueltos utilizando para ello los medios que se estimen convenientes Todos los trabajos sobre el reto propuesto quedar\u00e1n bajo las mismas licencias que esta web","title":"Reto propuesto"},{"location":"acel/","text":"A30-Aceler\u00f3metro de tres ejes ADXL345 \u00b6 El m\u00f3dulo ADXL345 es un aceler\u00f3metro MEMS (MicroelEctroMechanical Systems) o sistema microelectromec\u00e1nico de 3 ejes con capacidad de medici\u00f3n de hasta \u00b116g de fuerza gravitacional. Los datos de salida los entrega en formato digital en complemento a dos de 16 bits y se puede acceder a ellos a trav\u00e9s de una interfaz digital I2C. El ADXL345 es ideal para medir la aceleraci\u00f3n est\u00e1tica de la gravedad en aplicaciones de detecci\u00f3n de inclinaci\u00f3n, as\u00ed como la aceleraci\u00f3n din\u00e1mica resultante del movimiento o impacto. Su aspecto lo vemos en la Figura A30.1. Figura A30.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A30.2). Figura A30.2. Bloques Dispone de un solo bloque en el que se pueden seleccionar las opciones que vemos en la Figura A30.3. Figura A30.3. Opciones del bloque aceler\u00f3metro Los conceptos que vemos en la imagen se refieren a la rotaci\u00f3n del eje X (Roll) y la rotaci\u00f3n del eje Y (Pitch) y se ha prescindido del eje Z (Yaw). Para aprender mas sobre estos conceptos visita este enlace al blog de Luis Llamas . En la explicaci\u00f3n de los conceptos b\u00e1sicos de este tipo de dispositivos se muestra el gr\u00e1fico de la Figura A30.4, donde se comparan los conceptos de movimientos angulares aplicados a una aeronave. Figura A30.4. Movimientos angulares Pr\u00e1ctica A30.1 \u00b6 Vamos a mostrar por consola el valor de todas las opciones de que dispone el bloque. Mostrar en la consola cada una de las opciones del bloque del aceler\u00f3metro para poder hacerlas cambiar moviendo el mismo y ver los resultados que obtenemos. El programa lo tenemos en la Figura A30.5. Figura A30.5. Soluci\u00f3n A30.1 El resultado en consola lo vemos en la Figura A30.6. Figura A30.6. Consola de la actividad A30.1 Pr\u00e1ctica A30.2 \u00b6 Vamos a programar dos grados de libertad de un brazo robot. Realizar el programa para controlar un sistema como el de la Figura A30.7, que es un soporte para servos con 2 DOF (grados de libertad) para el montaje tipo cardan de una c\u00e1mara para un robot teledirigido. Figura A30.7. Soporte cardan con 2 DOF El programa lo tenemos en la Figura A30.8. Figura A30.8. Soluci\u00f3n A30.2","title":"A30-Aceler\u00f3metro de tres ejes ADXL345"},{"location":"acel/#a30-acelerometro-de-tres-ejes-adxl345","text":"El m\u00f3dulo ADXL345 es un aceler\u00f3metro MEMS (MicroelEctroMechanical Systems) o sistema microelectromec\u00e1nico de 3 ejes con capacidad de medici\u00f3n de hasta \u00b116g de fuerza gravitacional. Los datos de salida los entrega en formato digital en complemento a dos de 16 bits y se puede acceder a ellos a trav\u00e9s de una interfaz digital I2C. El ADXL345 es ideal para medir la aceleraci\u00f3n est\u00e1tica de la gravedad en aplicaciones de detecci\u00f3n de inclinaci\u00f3n, as\u00ed como la aceleraci\u00f3n din\u00e1mica resultante del movimiento o impacto. Su aspecto lo vemos en la Figura A30.1. Figura A30.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A30.2). Figura A30.2. Bloques Dispone de un solo bloque en el que se pueden seleccionar las opciones que vemos en la Figura A30.3. Figura A30.3. Opciones del bloque aceler\u00f3metro Los conceptos que vemos en la imagen se refieren a la rotaci\u00f3n del eje X (Roll) y la rotaci\u00f3n del eje Y (Pitch) y se ha prescindido del eje Z (Yaw). Para aprender mas sobre estos conceptos visita este enlace al blog de Luis Llamas . En la explicaci\u00f3n de los conceptos b\u00e1sicos de este tipo de dispositivos se muestra el gr\u00e1fico de la Figura A30.4, donde se comparan los conceptos de movimientos angulares aplicados a una aeronave. Figura A30.4. Movimientos angulares","title":"A30-Aceler\u00f3metro de tres ejes ADXL345"},{"location":"acel/#practica-a301","text":"Vamos a mostrar por consola el valor de todas las opciones de que dispone el bloque. Mostrar en la consola cada una de las opciones del bloque del aceler\u00f3metro para poder hacerlas cambiar moviendo el mismo y ver los resultados que obtenemos. El programa lo tenemos en la Figura A30.5. Figura A30.5. Soluci\u00f3n A30.1 El resultado en consola lo vemos en la Figura A30.6. Figura A30.6. Consola de la actividad A30.1","title":"Pr\u00e1ctica A30.1"},{"location":"acel/#practica-a302","text":"Vamos a programar dos grados de libertad de un brazo robot. Realizar el programa para controlar un sistema como el de la Figura A30.7, que es un soporte para servos con 2 DOF (grados de libertad) para el montaje tipo cardan de una c\u00e1mara para un robot teledirigido. Figura A30.7. Soporte cardan con 2 DOF El programa lo tenemos en la Figura A30.8. Figura A30.8. Soluci\u00f3n A30.2","title":"Pr\u00e1ctica A30.2"},{"location":"bt/","text":"A36-M\u00f3dulo Bluetooth \u00b6 El m\u00f3dulo Bluetooth 2.0 permite transmitir f\u00e1cilmente datos en serie. La frecuencia operativa se encuentra entre las bandas de frecuencia ISM (Industrial, Scientific and Medical) de 2,4 GHz, es decir en uso industriales, cient\u00edficos y m\u00e9dicos. Trabaja seg\u00fan el est\u00e1ndar Bluetooth 2.1+EDR. El Endpoint Detection and Response (conocido por su siglas en ingl\u00e9s EDR) es una herramienta que proporciona monitorizaci\u00f3n y an\u00e1lisis continuo del endpoint y la red. Tiene una antena incorporada que proporciona se\u00f1ales de alta calidad. Sus principales caracter\u00edsticas son: Protocolo Bluetooth: Bluetooth 2.1+ EDR Protocolo USB: USB v1.\u00bd.0 Frecuencia de funcionamiento: banda ISM de 2,4 GHz Modo de modulaci\u00f3n: GFSK (modulaci\u00f3n por desplazamiento de frecuencia de Gauss) Potencia de transmisi\u00f3n: \u2264 4dBm, clase 2 Sensibilidad: \u2264-84dBm a una tasa de error de bits del 0,1 % Velocidad de transferencia: as\u00edncrona: 2,1 Mbps (m\u00e1x.)/160 kbps; S\u00edncrono: 1Mbps/1Mbps Caracter\u00edstica de seguridad: Autenticaci\u00f3n y encriptaci\u00f3n Configuraci\u00f3n admitida: puerto serie Bluetooth Su aspecto lo vemos en la Figura A36.1. Figura A36.1. Aspecto Hay dos tipos de m\u00f3dulos Bluetooth b\u00e1sicos, los modelos HC-05 y HC-06. La diferencia entre ellos es que el HC-05 es maestro-esclavo, lo que significa que adem\u00e1s de recibir conexiones desde un ordenador, tablet o m\u00f3vil Android, tambi\u00e9n es capaz de generar conexiones hacia otros dispositivos bluetooth. El HC-06 solo puede funcionar en modo esclavo. En BlueTooth HC-05 y HC-06 hay disponible mas informaci\u00f3n sobre estos m\u00f3dulos. El m\u00f3dulo Bluetooth para la versi\u00f3n Easy Plug es del tipo HC-06. Un m\u00f3dulo de comunicaciones Bluetooth tiene las 4 conexiones siguientes que son las que se implementan en el conector RJ11: Vcc: Alimentaci\u00f3n 5V (+) Gnd: Alimentaci\u00f3n 0V (-) Tx: Transmisi\u00f3n de datos Rx: Recepci\u00f3n de datos Los pines Tx y Rx son precisamente los que utiliza la placa su programaci\u00f3n por lo que cuando utilicemos este m\u00f3dulo debemos tener muy presente la siguiente advertencia: \u00a1 MUY IMPORTANTE ! Para cargar los programas es imprescindible DESCONECTAR el m\u00f3dulo Bluetooth. Si lo dejamos conectado impedir\u00e1 la carga a trav\u00e9s del puerto serie (Tx y Rx). En el apartado de bloques de programaci\u00f3n, se encuentra en \"Comunicaciones\". La entrada Bluetooth dispone de los bloques que vemos Figura A36.2. Figura A36.2. Bloques Un programa como el que vemos en la Figura A36.3 nos permitir\u00e1 trabajar con comandos AT y el m\u00f3dulo Bluetooth para poder configurarlo en sus distintas opciones. Figura A36.3. Programa para comandos AT Para trabajar en el control por Bluetooth hacen faltan dos cosas: la placa Easy Plug con el m\u00f3dulo Bluetooth conectado y un programa y un m\u00f3vil Android con una aplicaci\u00f3n que permita el control. Para ello podemos crear nuestra propia aplicaci\u00f3n para Android utilizando por ejemplo APPInventor , que es una plataforma online en la que programar nuestras propias aplicaciones de modo muy similar a ArduinoBlocks. Pero no vamos a entrar en esto por ahora y lo que haremos ser\u00e1 utilizar una aplicaci\u00f3n ya existente como Arduino Bluetooth RC Car, que presenta el aspecto de la Figura A36.4 cuando se realiza su b\u00fasqueda para instalarla. Figura A36.4. Arduino Bluetooth RC Car lista para instalar Una vez instalada e iniciada la aplicaci\u00f3n nos muestra la imagen que vemos en la Figura A36.5. Figura A36.5. Arduino Bluetooth RC Car iniciada Aunque es una interfaz muy completa para el control de un coche es sencilla de utilizar e intuitiva, raz\u00f3n por la que la vamos a usar para probar nuestro Bluetooth. Si hacemos clic sobre el bot\u00f3n del engranaje (men\u00fa) se nos abren las opciones que vemos en la Figura A36.6. Figura A36.6. Arduino Bluetooth RC Car men\u00fa Si clicamos sobre \u201cSettings\u201d nos aparece una ventana en la que se nos informa de los comandos/caracteres que enviamos desde la aplicaci\u00f3n. En la Figura A36.7 vemos parte de la informaci\u00f3n que nos da \u201cSetting\u201d. Figura A36.7. Informaci\u00f3n de Setting Por ejemplo, cuando pulsamos el bot\u00f3n \u201cForward\u201d (adelante) se envia el car\u00e1cter \u201cF\u201d que en una letra del c\u00f3digo ASCII por lo que en ArduinoBlocks debemos leer precisamente valores ASCII. El c\u00f3digo ASCII pronunciado como \u201caski\u201d (American Standard Code for Information Interchange o C\u00f3digo Est\u00e1ndar estadounidense para el Intercambio de Informaci\u00f3n) adoptado internacionalmente y que en sus primeros 128 s\u00edmbolos b\u00e1sicamente define los n\u00fameros, letras may\u00fasculas y min\u00fasculas y los principales signos de puntuaci\u00f3n y que son comunes en casi todo el mundo. En la parte extendida es donde se definen los caracteres especiales de cada idioma, pero en esto ya no hay tanta unanimidad. El bloque encargado de traducir los datos le\u00eddos en bytes es \u201cValor ASCII\u201d y se encuentra al final del men\u00fa \u201cTexto\u201d. Con el m\u00f3dulo Bluetooth conectado a alimentaci\u00f3n realizamos las tareas de emparejamiento habituales entre el m\u00f3vil y el m\u00f3dulo HC-06. Habitualmente la contrase\u00f1a de emparejamiento del m\u00f3dulo es 1234. Pr\u00e1ctica A36.1 \u00b6 Vamos a enviar comandos desde la APP para recibirlos via Bluetooth. Encender un LED utilizando el comando \u201cForward\u201d y apagarlo con el comando \u201cBack\u201d. El programa lo tenemos en la Figura A36.8. Figura A36.8. Soluci\u00f3n A36.1 Desconectamos el m\u00f3dulo Bluetooth y cargamos el programa en la placa. Volvemos a conectar el m\u00f3dulo HC-06 y desde el men\u00fa de la APP seleccionamos \u201cConnect to car\u201d para que se muestre la lista de dispositivos Bluetooth emparejados. Localizamos el m\u00f3dulo y lo seleccionamos, como en la Figura A36.9. Figura A36.9. Dispositivos emparejados en car Tras unos instantes el circulo rojo que parpadea en la esquina superior izquierda se queda fijo y en color verde, la APP nos informa de que est\u00e1 conectada al HC-06 y el LED del m\u00f3dulo que estaba parpadeando se queda fijo. En la Figura A36.10 vemos este estado. Figura A36.10. App conectada y lista Ya podemos probar los botones y comprobar el funcionamiento del programa. Para dejar de estar conectados sin abandonar la APP podemos seleccionar \u201cDisconnect from car\u201d (Figura A36.11) del men\u00fa. L\u00f3gicamente cuando cerramos la aplicaci\u00f3n tambi\u00e9n se produce la desconexi\u00f3n. Figura A36.11. Disconnect from car","title":"A36-M\u00f3dulo Bluetooth"},{"location":"bt/#a36-modulo-bluetooth","text":"El m\u00f3dulo Bluetooth 2.0 permite transmitir f\u00e1cilmente datos en serie. La frecuencia operativa se encuentra entre las bandas de frecuencia ISM (Industrial, Scientific and Medical) de 2,4 GHz, es decir en uso industriales, cient\u00edficos y m\u00e9dicos. Trabaja seg\u00fan el est\u00e1ndar Bluetooth 2.1+EDR. El Endpoint Detection and Response (conocido por su siglas en ingl\u00e9s EDR) es una herramienta que proporciona monitorizaci\u00f3n y an\u00e1lisis continuo del endpoint y la red. Tiene una antena incorporada que proporciona se\u00f1ales de alta calidad. Sus principales caracter\u00edsticas son: Protocolo Bluetooth: Bluetooth 2.1+ EDR Protocolo USB: USB v1.\u00bd.0 Frecuencia de funcionamiento: banda ISM de 2,4 GHz Modo de modulaci\u00f3n: GFSK (modulaci\u00f3n por desplazamiento de frecuencia de Gauss) Potencia de transmisi\u00f3n: \u2264 4dBm, clase 2 Sensibilidad: \u2264-84dBm a una tasa de error de bits del 0,1 % Velocidad de transferencia: as\u00edncrona: 2,1 Mbps (m\u00e1x.)/160 kbps; S\u00edncrono: 1Mbps/1Mbps Caracter\u00edstica de seguridad: Autenticaci\u00f3n y encriptaci\u00f3n Configuraci\u00f3n admitida: puerto serie Bluetooth Su aspecto lo vemos en la Figura A36.1. Figura A36.1. Aspecto Hay dos tipos de m\u00f3dulos Bluetooth b\u00e1sicos, los modelos HC-05 y HC-06. La diferencia entre ellos es que el HC-05 es maestro-esclavo, lo que significa que adem\u00e1s de recibir conexiones desde un ordenador, tablet o m\u00f3vil Android, tambi\u00e9n es capaz de generar conexiones hacia otros dispositivos bluetooth. El HC-06 solo puede funcionar en modo esclavo. En BlueTooth HC-05 y HC-06 hay disponible mas informaci\u00f3n sobre estos m\u00f3dulos. El m\u00f3dulo Bluetooth para la versi\u00f3n Easy Plug es del tipo HC-06. Un m\u00f3dulo de comunicaciones Bluetooth tiene las 4 conexiones siguientes que son las que se implementan en el conector RJ11: Vcc: Alimentaci\u00f3n 5V (+) Gnd: Alimentaci\u00f3n 0V (-) Tx: Transmisi\u00f3n de datos Rx: Recepci\u00f3n de datos Los pines Tx y Rx son precisamente los que utiliza la placa su programaci\u00f3n por lo que cuando utilicemos este m\u00f3dulo debemos tener muy presente la siguiente advertencia: \u00a1 MUY IMPORTANTE ! Para cargar los programas es imprescindible DESCONECTAR el m\u00f3dulo Bluetooth. Si lo dejamos conectado impedir\u00e1 la carga a trav\u00e9s del puerto serie (Tx y Rx). En el apartado de bloques de programaci\u00f3n, se encuentra en \"Comunicaciones\". La entrada Bluetooth dispone de los bloques que vemos Figura A36.2. Figura A36.2. Bloques Un programa como el que vemos en la Figura A36.3 nos permitir\u00e1 trabajar con comandos AT y el m\u00f3dulo Bluetooth para poder configurarlo en sus distintas opciones. Figura A36.3. Programa para comandos AT Para trabajar en el control por Bluetooth hacen faltan dos cosas: la placa Easy Plug con el m\u00f3dulo Bluetooth conectado y un programa y un m\u00f3vil Android con una aplicaci\u00f3n que permita el control. Para ello podemos crear nuestra propia aplicaci\u00f3n para Android utilizando por ejemplo APPInventor , que es una plataforma online en la que programar nuestras propias aplicaciones de modo muy similar a ArduinoBlocks. Pero no vamos a entrar en esto por ahora y lo que haremos ser\u00e1 utilizar una aplicaci\u00f3n ya existente como Arduino Bluetooth RC Car, que presenta el aspecto de la Figura A36.4 cuando se realiza su b\u00fasqueda para instalarla. Figura A36.4. Arduino Bluetooth RC Car lista para instalar Una vez instalada e iniciada la aplicaci\u00f3n nos muestra la imagen que vemos en la Figura A36.5. Figura A36.5. Arduino Bluetooth RC Car iniciada Aunque es una interfaz muy completa para el control de un coche es sencilla de utilizar e intuitiva, raz\u00f3n por la que la vamos a usar para probar nuestro Bluetooth. Si hacemos clic sobre el bot\u00f3n del engranaje (men\u00fa) se nos abren las opciones que vemos en la Figura A36.6. Figura A36.6. Arduino Bluetooth RC Car men\u00fa Si clicamos sobre \u201cSettings\u201d nos aparece una ventana en la que se nos informa de los comandos/caracteres que enviamos desde la aplicaci\u00f3n. En la Figura A36.7 vemos parte de la informaci\u00f3n que nos da \u201cSetting\u201d. Figura A36.7. Informaci\u00f3n de Setting Por ejemplo, cuando pulsamos el bot\u00f3n \u201cForward\u201d (adelante) se envia el car\u00e1cter \u201cF\u201d que en una letra del c\u00f3digo ASCII por lo que en ArduinoBlocks debemos leer precisamente valores ASCII. El c\u00f3digo ASCII pronunciado como \u201caski\u201d (American Standard Code for Information Interchange o C\u00f3digo Est\u00e1ndar estadounidense para el Intercambio de Informaci\u00f3n) adoptado internacionalmente y que en sus primeros 128 s\u00edmbolos b\u00e1sicamente define los n\u00fameros, letras may\u00fasculas y min\u00fasculas y los principales signos de puntuaci\u00f3n y que son comunes en casi todo el mundo. En la parte extendida es donde se definen los caracteres especiales de cada idioma, pero en esto ya no hay tanta unanimidad. El bloque encargado de traducir los datos le\u00eddos en bytes es \u201cValor ASCII\u201d y se encuentra al final del men\u00fa \u201cTexto\u201d. Con el m\u00f3dulo Bluetooth conectado a alimentaci\u00f3n realizamos las tareas de emparejamiento habituales entre el m\u00f3vil y el m\u00f3dulo HC-06. Habitualmente la contrase\u00f1a de emparejamiento del m\u00f3dulo es 1234.","title":"A36-M\u00f3dulo Bluetooth"},{"location":"bt/#practica-a361","text":"Vamos a enviar comandos desde la APP para recibirlos via Bluetooth. Encender un LED utilizando el comando \u201cForward\u201d y apagarlo con el comando \u201cBack\u201d. El programa lo tenemos en la Figura A36.8. Figura A36.8. Soluci\u00f3n A36.1 Desconectamos el m\u00f3dulo Bluetooth y cargamos el programa en la placa. Volvemos a conectar el m\u00f3dulo HC-06 y desde el men\u00fa de la APP seleccionamos \u201cConnect to car\u201d para que se muestre la lista de dispositivos Bluetooth emparejados. Localizamos el m\u00f3dulo y lo seleccionamos, como en la Figura A36.9. Figura A36.9. Dispositivos emparejados en car Tras unos instantes el circulo rojo que parpadea en la esquina superior izquierda se queda fijo y en color verde, la APP nos informa de que est\u00e1 conectada al HC-06 y el LED del m\u00f3dulo que estaba parpadeando se queda fijo. En la Figura A36.10 vemos este estado. Figura A36.10. App conectada y lista Ya podemos probar los botones y comprobar el funcionamiento del programa. Para dejar de estar conectados sin abandonar la APP podemos seleccionar \u201cDisconnect from car\u201d (Figura A36.11) del men\u00fa. L\u00f3gicamente cuando cerramos la aplicaci\u00f3n tambi\u00e9n se produce la desconexi\u00f3n. Figura A36.11. Disconnect from car","title":"Pr\u00e1ctica A36.1"},{"location":"buzzer/","text":"A08-Zumbadores pasivo y activo \u00b6 En la siguiente actividad trabajaremos con el zumbador, el cual es un actuador que se conecta a un puerto digital. Este zumbador es pasivo, ya que no puede ser accionado por \u00e9l mismo sino por pulsos externos de diferente duraci\u00f3n y frecuencia. Puede ser utilizado como un peque\u00f1o \"altavoz\" que puede generar melod\u00edas musicales. El sonido que emite el zumbador depende de la frecuencia de emisi\u00f3n del sonido. La frecuencia se entiende como el n\u00famero de repeticiones por unidad de tiempo. El sonido se transmite en forma de onda. Por tanto, la frecuencia de un sonido es el n\u00famero de oscilaciones por segundo. En la Figura A08.1 vemos el aspecto del zumbador. Figura A08.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"actuadores\" (Figura A08.2). Hay diferentes opciones de programaci\u00f3n, concretamente 4 bloques espec\u00edficos, desde seleccionar una canci\u00f3n ya creada o decidir notas concretas. Figura A08.2. Bloques En la Figura A08.3 vemos la descripci\u00f3n del bloque \"zumbador\". Figura A08.3. Descripci\u00f3n Pr\u00e1ctica A08.1 \u00b6 En esta pr\u00e1ctica crearemos la escala musical. Para ello puedes tener en cuenta la siguiente tabla. Nota Frecuencia Nota Frecuencia Nota Frecuencia Do 261.6 Fa 349.2 La 440 Do# 277.2 Fa# 370 La# 466.2 Re# 293.7 Sol 392 Si 493,2 Mi 329.6 Sol# 415,3 Do 523,3 Crea la escala de \"Do\". En la Figura A08.4 vemos la soluci\u00f3n. Figura A08.4. Soluci\u00f3n A08.1 Pr\u00e1ctica A08.2 \u00b6 En esta pr\u00e1ctica enviaremos al zumbador, una m\u00fasica ya dise\u00f1ada por el programa. El zumbador reproduzca una canci\u00f3n y tras una espera de 5 segundos, reproducir\u00e1 otra. En la Figura A08.5 vemos la soluci\u00f3n. Figura A08.5. Soluci\u00f3n A08.2 \u00a1Ahora puedes probar todas las canciones que quieras de la plataforma ArduinoBlocks! Puedes buscar a\u00fan m\u00e1s canciones si haces clic con el bot\u00f3n derecho sobre el bloque y seleccionando \"ayuda\" (Figura A08.6). Figura A08.6. Buscar canciones Se muestran (Figura A08.7) enlaces a distintas webs donde obtenerlas. Figura A08.7. Enlaces a webs con canciones Existe otro tipo de zumbador que incluye un oscilador que genera una frecuencia audible fija y que se conoce como zumbador pasivo y en realidad es el que de forma correcta se puede denominar como zumbador. Este es mucho mas sencillo de usar ya que basta con conectarlo a un pin digital y cuando pongamos a nivel alto este pin el zumbador generar\u00e1 su zumbido caracter\u00edstico. Con este tipo de zumbador no se pueden generar melod\u00edas. El aspecto cuando lo recibimos es el de la Figura A08.8. Figura A08.8. Aspecto zumbador activo nuevo Cuando est\u00e1 en este estado se distingue del zumbador pasivo o altavoz por la pegatina de protecci\u00f3n, pero esta hay que quitarla para oir el zumbido y sin ella es dificil distinguir un tipo del otro, as\u00ed que en este caso deberemos crear un programa con alguna melod\u00eda y si no se reproduce correctamente es que tenemos conectado el zumbador activo en lugar del pasivo. Lo mejor es marcar alguno de los dos cuando podemos distinguirlos. Pr\u00e1ctica A08.3 \u00b6 En esta pr\u00e1ctica crearemos con un pulsador y el zumbador activo un timbre de puerta. El zumbador activo debe estar emitiendo sonido mientras tengamos el pulsador accionado. En la Figura A08.9 vemos la soluci\u00f3n. Figura A08.9. Soluci\u00f3n A08.3","title":"A08-Zumbadores"},{"location":"buzzer/#a08-zumbadores-pasivo-y-activo","text":"En la siguiente actividad trabajaremos con el zumbador, el cual es un actuador que se conecta a un puerto digital. Este zumbador es pasivo, ya que no puede ser accionado por \u00e9l mismo sino por pulsos externos de diferente duraci\u00f3n y frecuencia. Puede ser utilizado como un peque\u00f1o \"altavoz\" que puede generar melod\u00edas musicales. El sonido que emite el zumbador depende de la frecuencia de emisi\u00f3n del sonido. La frecuencia se entiende como el n\u00famero de repeticiones por unidad de tiempo. El sonido se transmite en forma de onda. Por tanto, la frecuencia de un sonido es el n\u00famero de oscilaciones por segundo. En la Figura A08.1 vemos el aspecto del zumbador. Figura A08.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"actuadores\" (Figura A08.2). Hay diferentes opciones de programaci\u00f3n, concretamente 4 bloques espec\u00edficos, desde seleccionar una canci\u00f3n ya creada o decidir notas concretas. Figura A08.2. Bloques En la Figura A08.3 vemos la descripci\u00f3n del bloque \"zumbador\". Figura A08.3. Descripci\u00f3n","title":"A08-Zumbadores pasivo y activo"},{"location":"buzzer/#practica-a081","text":"En esta pr\u00e1ctica crearemos la escala musical. Para ello puedes tener en cuenta la siguiente tabla. Nota Frecuencia Nota Frecuencia Nota Frecuencia Do 261.6 Fa 349.2 La 440 Do# 277.2 Fa# 370 La# 466.2 Re# 293.7 Sol 392 Si 493,2 Mi 329.6 Sol# 415,3 Do 523,3 Crea la escala de \"Do\". En la Figura A08.4 vemos la soluci\u00f3n. Figura A08.4. Soluci\u00f3n A08.1","title":"Pr\u00e1ctica A08.1"},{"location":"buzzer/#practica-a082","text":"En esta pr\u00e1ctica enviaremos al zumbador, una m\u00fasica ya dise\u00f1ada por el programa. El zumbador reproduzca una canci\u00f3n y tras una espera de 5 segundos, reproducir\u00e1 otra. En la Figura A08.5 vemos la soluci\u00f3n. Figura A08.5. Soluci\u00f3n A08.2 \u00a1Ahora puedes probar todas las canciones que quieras de la plataforma ArduinoBlocks! Puedes buscar a\u00fan m\u00e1s canciones si haces clic con el bot\u00f3n derecho sobre el bloque y seleccionando \"ayuda\" (Figura A08.6). Figura A08.6. Buscar canciones Se muestran (Figura A08.7) enlaces a distintas webs donde obtenerlas. Figura A08.7. Enlaces a webs con canciones Existe otro tipo de zumbador que incluye un oscilador que genera una frecuencia audible fija y que se conoce como zumbador pasivo y en realidad es el que de forma correcta se puede denominar como zumbador. Este es mucho mas sencillo de usar ya que basta con conectarlo a un pin digital y cuando pongamos a nivel alto este pin el zumbador generar\u00e1 su zumbido caracter\u00edstico. Con este tipo de zumbador no se pueden generar melod\u00edas. El aspecto cuando lo recibimos es el de la Figura A08.8. Figura A08.8. Aspecto zumbador activo nuevo Cuando est\u00e1 en este estado se distingue del zumbador pasivo o altavoz por la pegatina de protecci\u00f3n, pero esta hay que quitarla para oir el zumbido y sin ella es dificil distinguir un tipo del otro, as\u00ed que en este caso deberemos crear un programa con alguna melod\u00eda y si no se reproduce correctamente es que tenemos conectado el zumbador activo en lugar del pasivo. Lo mejor es marcar alguno de los dos cuando podemos distinguirlos.","title":"Pr\u00e1ctica A08.2"},{"location":"buzzer/#practica-a083","text":"En esta pr\u00e1ctica crearemos con un pulsador y el zumbador activo un timbre de puerta. El zumbador activo debe estar emitiendo sonido mientras tengamos el pulsador accionado. En la Figura A08.9 vemos la soluci\u00f3n. Figura A08.9. Soluci\u00f3n A08.3","title":"Pr\u00e1ctica A08.3"},{"location":"co2/","text":"A39-CCS811 Sensor de eCO2 (Di\u00f3xido de Carbono Equivalente) y TVOC \u00b6 El sensor de gas CCS811B puede detectar una amplia gama de Compuestos Org\u00e1nicos Vol\u00e1tiles (VOCs del ingl\u00e9s Volatile Organic Compound) y est\u00e1 dise\u00f1ado para monitorizar la calidad del aire. El sensor devuelve una lectura de VOC Totales (TVOC) y una lectura de di\u00f3xido de carbono equivalente (eCO2). Para aprender mas sobre los conceptos de VOC y eCO2 y como utilizar el sensor se aconseja visitar la web sobre Sem\u00e1foro \u00f3ptico-ac\u00fastico de CO2 y nivel de ruido creada por el Club Rob\u00f3tica Granada en su entrada Algunos conceptos sobre CO2 y VOC . Su aspecto lo vemos en la Figura A39.1. Figura A39.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A37.2). Figura A39.2. Bloques Se puede seleccionar entre ppm o mg/m\u00b3 como unidades para el CO2 y los VOC solamente se pueden mostrar en ppb. Pr\u00e1ctica A39.1 \u00b6 Vamos a medir la calidad del aire de una habitaci\u00f3n. Mostrar en una LCD un mensaje de bienvenida, otro relativo a lo que hace el programa y los datos medidos por el sensor CCS811. El programa lo tenemos en la Figura A39.3. Figura A39.3. Soluci\u00f3n A39.1 Un programa como este arroja unos resultados en la LCD como los que vemos en las im\u00e1genes de la Figura A39.4. Figura A39.4. Resultados A39.1","title":"A39-Sensor de eCO2"},{"location":"co2/#a39-ccs811-sensor-de-eco2-dioxido-de-carbono-equivalente-y-tvoc","text":"El sensor de gas CCS811B puede detectar una amplia gama de Compuestos Org\u00e1nicos Vol\u00e1tiles (VOCs del ingl\u00e9s Volatile Organic Compound) y est\u00e1 dise\u00f1ado para monitorizar la calidad del aire. El sensor devuelve una lectura de VOC Totales (TVOC) y una lectura de di\u00f3xido de carbono equivalente (eCO2). Para aprender mas sobre los conceptos de VOC y eCO2 y como utilizar el sensor se aconseja visitar la web sobre Sem\u00e1foro \u00f3ptico-ac\u00fastico de CO2 y nivel de ruido creada por el Club Rob\u00f3tica Granada en su entrada Algunos conceptos sobre CO2 y VOC . Su aspecto lo vemos en la Figura A39.1. Figura A39.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A37.2). Figura A39.2. Bloques Se puede seleccionar entre ppm o mg/m\u00b3 como unidades para el CO2 y los VOC solamente se pueden mostrar en ppb.","title":"A39-CCS811 Sensor de eCO2 (Di\u00f3xido de Carbono Equivalente) y TVOC"},{"location":"co2/#practica-a391","text":"Vamos a medir la calidad del aire de una habitaci\u00f3n. Mostrar en una LCD un mensaje de bienvenida, otro relativo a lo que hace el programa y los datos medidos por el sensor CCS811. El programa lo tenemos en la Figura A39.3. Figura A39.3. Soluci\u00f3n A39.1 Un programa como este arroja unos resultados en la LCD como los que vemos en las im\u00e1genes de la Figura A39.4. Figura A39.4. Resultados A39.1","title":"Pr\u00e1ctica A39.1"},{"location":"colision/","text":"A17-Sensor de colisi\u00f3n \u00b6 El sensor de colisi\u00f3n o choque, es un interruptor de acci\u00f3n r\u00e1pida del tipo final de carrera que se activa con muy poca fuerza f\u00edsica. Es un m\u00f3dulo de encendido y apagado digital necesario para la electr\u00f3nica elemental. Su aspecto lo vemos en la Figura A17.1. Figura A17.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A17.2). Figura A17.2. Bloques Pr\u00e1ctica A17.1 \u00b6 En esta pr\u00e1ctica vamos a encender y apagar unos LEDs cuando se acciona el interruptor de choque al tiempo que mostramos por la consola serie el valor de la variable \u201cchoque\u201d. Leer el valor booleano entregado por el sensor de choque y si es \u201c1\u201d encender un LED verde mientras el rojo se mantiene apagado y si es \u201c0\u201d apagamos el verde y encendemos el rojo. En ambos casos debemos mostrar el valor de la variable \u201cchoque\u201d por consola. El programa lo tenemos en la Figura A17.3. Figura A17.3. Soluci\u00f3n A17.1","title":"A17-Sensor de colisi\u00f3n"},{"location":"colision/#a17-sensor-de-colision","text":"El sensor de colisi\u00f3n o choque, es un interruptor de acci\u00f3n r\u00e1pida del tipo final de carrera que se activa con muy poca fuerza f\u00edsica. Es un m\u00f3dulo de encendido y apagado digital necesario para la electr\u00f3nica elemental. Su aspecto lo vemos en la Figura A17.1. Figura A17.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A17.2). Figura A17.2. Bloques","title":"A17-Sensor de colisi\u00f3n"},{"location":"colision/#practica-a171","text":"En esta pr\u00e1ctica vamos a encender y apagar unos LEDs cuando se acciona el interruptor de choque al tiempo que mostramos por la consola serie el valor de la variable \u201cchoque\u201d. Leer el valor booleano entregado por el sensor de choque y si es \u201c1\u201d encender un LED verde mientras el rojo se mantiene apagado y si es \u201c0\u201d apagamos el verde y encendemos el rojo. En ambos casos debemos mostrar el valor de la variable \u201cchoque\u201d por consola. El programa lo tenemos en la Figura A17.3. Figura A17.3. Soluci\u00f3n A17.1","title":"Pr\u00e1ctica A17.1"},{"location":"color/","text":"A40-Sensor de color TCS34725 \u00b6 El modo RGB es un est\u00e1ndar de colores en la industria, que se obtiene cambiando los tres colores fundamentales: Rojo (Red), Verde (Green) y Azul (Blue) y superponi\u00e9ndolos entre s\u00ed. Este est\u00e1ndar incluye casi todos los colores que la visi\u00f3n humana puede percibir y es uno de los sistemas de colores m\u00e1s utilizados. En la Figura A40.1 vemos como se comporta el modo aditivo de estos colores. Figura A40.1. Modo aditivo RGB El sensor de color TCS34725 es un sensor de reconocimiento de colores RGB que puede reconocer el color de la superficie de un objeto a trav\u00e9s de la detecci\u00f3n \u00f3ptica. Para evitar la interferencia del entorno y aumentar la precisi\u00f3n, lleva incorporada una placa de protecci\u00f3n que es un filtro de luz infrarroja (Figura A40.2), de modo que su influencia en la medida se minimiza haciendo que el reconocimiento del color sea m\u00e1s preciso. Figura A40.2. Filtro IR El sensor tambi\u00e9n incorpora 4 LED de color amarillo rodeando al mismo, que garantizan que el sensor pueda usarse en condiciones de luz ambiental. Trabaja a una frecuencia de reloj de 0 a 400 Khz y la distancia de detecci\u00f3n va de 3 a 10 mm. Su aspecto lo vemos en la Figura A40.3. Figura A40.3. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A40.4). Figura A40.4. Bloques Pr\u00e1ctica A40.1 \u00b6 Vamos a reconocer diferentes colores. Mostrar en la consola el color detectado de los posibles del modo aditivo RGB de la Figura A40.1. El programa lo tenemos en la Figura A40.5. Los nombres de los colores son: Rojo, Verde, Azul, amarillo, Cian, Violeta y Blanco Figura A40.5. Soluci\u00f3n A40.1","title":"A40-Sensor de color"},{"location":"color/#a40-sensor-de-color-tcs34725","text":"El modo RGB es un est\u00e1ndar de colores en la industria, que se obtiene cambiando los tres colores fundamentales: Rojo (Red), Verde (Green) y Azul (Blue) y superponi\u00e9ndolos entre s\u00ed. Este est\u00e1ndar incluye casi todos los colores que la visi\u00f3n humana puede percibir y es uno de los sistemas de colores m\u00e1s utilizados. En la Figura A40.1 vemos como se comporta el modo aditivo de estos colores. Figura A40.1. Modo aditivo RGB El sensor de color TCS34725 es un sensor de reconocimiento de colores RGB que puede reconocer el color de la superficie de un objeto a trav\u00e9s de la detecci\u00f3n \u00f3ptica. Para evitar la interferencia del entorno y aumentar la precisi\u00f3n, lleva incorporada una placa de protecci\u00f3n que es un filtro de luz infrarroja (Figura A40.2), de modo que su influencia en la medida se minimiza haciendo que el reconocimiento del color sea m\u00e1s preciso. Figura A40.2. Filtro IR El sensor tambi\u00e9n incorpora 4 LED de color amarillo rodeando al mismo, que garantizan que el sensor pueda usarse en condiciones de luz ambiental. Trabaja a una frecuencia de reloj de 0 a 400 Khz y la distancia de detecci\u00f3n va de 3 a 10 mm. Su aspecto lo vemos en la Figura A40.3. Figura A40.3. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A40.4). Figura A40.4. Bloques","title":"A40-Sensor de color TCS34725"},{"location":"color/#practica-a401","text":"Vamos a reconocer diferentes colores. Mostrar en la consola el color detectado de los posibles del modo aditivo RGB de la Figura A40.1. El programa lo tenemos en la Figura A40.5. Los nombres de los colores son: Rojo, Verde, Azul, amarillo, Cian, Violeta y Blanco Figura A40.5. Soluci\u00f3n A40.1","title":"Pr\u00e1ctica A40.1"},{"location":"consola/","text":"A04-Consola serie \u00b6 En esta pr\u00e1ctica trabajaremos con la consola. Es una funci\u00f3n del programa ArduinoBlocks que podemos programar para que se env\u00ede informaci\u00f3n a la pantalla de nuestro ordenador. Para poder \"enviar\" esta informaci\u00f3n necesitamos inicializar el \"Puerto serie\". Por tanto, dentro del bloque inicializar pondremos: \"Iniciar Bauds\", como vemos en la Figura A04.1. En ese caso, para enviar mensajes a la consola con el valor 9600 es suficiente. Figura A04.1. Inicializar puerto serie Pr\u00e1ctica A04.1 \u00b6 Comenzaremos esta primera actividad, enviando un mensaje a la consola, que diga \"Hola consola\". Es necesario inicializar el Puerto Serie, utilizando los Bauds. \u2022 Cada segundo, en la consola debe aparecer \"Hola consola\" con salto de l\u00ednea. El programa lo vemos en la Figura A04.2. Figura A04.2. Mensaje en consola Pr\u00e1ctica A04.2 \u00b6 Ahora que sabemos enviar un mensaje a la consola, combinaremos diferentes bloques de programaci\u00f3n: control, actuadores, puerto serie y tiempo. \u2022 Este programa, que vemos en la Figura A04.3, se repite durante 5 veces y entre repetici\u00f3n y repetici\u00f3n hay un segundo de espera: se enciende el LED y autom\u00e1ticamente se env\u00eda a la consola \"LED ON\", durante 3 segundos. Luego se apaga, y en la consola aparece \"LED OFF\" durante 3 segundos. Figura A04.3. Soluci\u00f3n A04.2 Pr\u00e1ctica A04.3 \u00b6 Ahora programaremos utilizando los bloques de l\u00f3gica. \u2022 Si hacemos clic en el pulsador t\u00e1ctil, el LED se enciende y en la consola aparece \"LED ON\". En cambio, si hacemos clic en el pulsador normal, el LED se apaga y en la consola se escribe: \"LED OFF\". El programa lo vemos en la Figura A04.4. Figura A04.4. Soluci\u00f3n A04.3","title":"A04-Consola serie"},{"location":"consola/#a04-consola-serie","text":"En esta pr\u00e1ctica trabajaremos con la consola. Es una funci\u00f3n del programa ArduinoBlocks que podemos programar para que se env\u00ede informaci\u00f3n a la pantalla de nuestro ordenador. Para poder \"enviar\" esta informaci\u00f3n necesitamos inicializar el \"Puerto serie\". Por tanto, dentro del bloque inicializar pondremos: \"Iniciar Bauds\", como vemos en la Figura A04.1. En ese caso, para enviar mensajes a la consola con el valor 9600 es suficiente. Figura A04.1. Inicializar puerto serie","title":"A04-Consola serie"},{"location":"consola/#practica-a041","text":"Comenzaremos esta primera actividad, enviando un mensaje a la consola, que diga \"Hola consola\". Es necesario inicializar el Puerto Serie, utilizando los Bauds. \u2022 Cada segundo, en la consola debe aparecer \"Hola consola\" con salto de l\u00ednea. El programa lo vemos en la Figura A04.2. Figura A04.2. Mensaje en consola","title":"Pr\u00e1ctica A04.1"},{"location":"consola/#practica-a042","text":"Ahora que sabemos enviar un mensaje a la consola, combinaremos diferentes bloques de programaci\u00f3n: control, actuadores, puerto serie y tiempo. \u2022 Este programa, que vemos en la Figura A04.3, se repite durante 5 veces y entre repetici\u00f3n y repetici\u00f3n hay un segundo de espera: se enciende el LED y autom\u00e1ticamente se env\u00eda a la consola \"LED ON\", durante 3 segundos. Luego se apaga, y en la consola aparece \"LED OFF\" durante 3 segundos. Figura A04.3. Soluci\u00f3n A04.2","title":"Pr\u00e1ctica A04.2"},{"location":"consola/#practica-a043","text":"Ahora programaremos utilizando los bloques de l\u00f3gica. \u2022 Si hacemos clic en el pulsador t\u00e1ctil, el LED se enciende y en la consola aparece \"LED ON\". En cambio, si hacemos clic en el pulsador normal, el LED se apaga y en la consola se escribe: \"LED OFF\". El programa lo vemos en la Figura A04.4. Figura A04.4. Soluci\u00f3n A04.3","title":"Pr\u00e1ctica A04.3"},{"location":"dht11/","text":"A06 - Sensor de Temperatura y humedad DHT11 \u00b6 En esta sexta actividad aprenderemos a programar el sensor de temperatura y humedad o c\u00f3mo se llama en ArduinoBlocks: DHT11. Este sensor se conecta a un puerto digital. El sensor DHT11 realmente es un sensor de temperatura y humedad. Tiene una salida de se\u00f1al digital, que funciona en un rango de temperaturas entre 0 y 50 \u00b0C, con un error de 2\u00baC y un rango de humedad entre 20 y 90%, con un error de un 5%. En la Figura A06.1 vemos su aspecto. Figura A06.1. Aspecto DHT11 En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\", como vemos en la Figura A06.2. Figura A06.2. Bloque DHT11 Antes de empezar la pr\u00e1ctica, establecemos dos variables nuevas (Figura A06.3): una para la temperatura y otra para la humedad. Figura A06.3. Declaraci\u00f3n de variables Pr\u00e1ctica A06.1 \u00b6 En esta primera pr\u00e1ctica enviaremos los valores a la consola, es decir, los grados cent\u00edgrados y el porcentaje de humedad de la habitaci\u00f3n donde estamos. Recuerda y utiliza el bloque de programaci\u00f3n \"crear texto con\", el cual te permite a\u00f1adir diferentes mensajes en una misma l\u00ednea de texto. Env\u00eda a la consola los valores de temperatura y humedad cada 3 segundos. En la consola debe aparecer: Temperatura: X \u00baC seguido de Humedad: X %. En la Figura A06.4 vemos el programa. Figura A06.4. Soluci\u00f3n A06.1 Pr\u00e1ctica A06.2 \u00b6 Seguidamente, trabajaremos con la herramienta Plotter. Esta es parecida a la consola, de hecho se encuentra en el desplegable de consola. Esta herramienta crea en tiempo real una estad\u00edstica de los valores obtenidos. Los bloques para programarlo, los encontraremos en el apartado 'Puerto serie'. En la Figura A06.5 vemos esto. Figura A06.5. Abrir Plotter y bloque programaci\u00f3n Env\u00eda cada 3 segundos al Serial Plotter los valores de temperatura y humedad. En la Figura A06.6 vemos el programa y el Plotter. Figura A06.6. Soluci\u00f3n A06.2 y salida en Serial Plotter Env\u00eda a la consola los valores de temperatura y humedad cada 3 segundos. En la consola debe aparecer: Temperatura: X \u00baC seguido de Humedad: X %. En la Figura A06.7 vemos el programa. Figura A06.7. Soluci\u00f3n A06.1 Pr\u00e1ctica A06.3 \u00b6 Otra forma de poder visualizar valores es haciendo uso de pantallas externas, es decir, pantallas conectadas a la placa Easy Plug. Tal y como podemos observar en el apartado de programaci\u00f3n tenemos tres pantallas: Pantalla LCD: Es una pantalla LCD de 16 caracteres por 2 l\u00edneas con fondo azul y luz blanca. Se conecta al puerto I2C. Tiene el aspecto de la Figura A06.8. Figura A06.8. LCD1602 Pantalla OLED: El nombre es una abreviatura de \u201cOrganic Light-Emitting Diode\u201d que se traduce como \"Diodo Emisor de luz org\u00e1nico\". Una pantalla OLED es una matriz de LEDS org\u00e1nicos que se iluminan cuando emiten energ\u00eda y que tiene el aspecto de la Figura A06.9. Figura A06.9. OLED LedMatrix 8x8: Es una matriz de de 8x8 LEDS con el aspecto de la Figura A06.10. Figura A06.10. LedMatrix 8x8 En esta pr\u00e1ctica A06.3 enviaremos los mismos datos que hemos estado enviando a Consola y al Serial Plotter a nuestra pantalla LCD. As\u00ed pues, debes conectar la placa al puerto I2C. Los bloques de programaci\u00f3n de la pantalla LCD son los de la Figura A06.11. Figura A06.11. Bloques Hay que seleccionar el primero, y colocarlo en el bloque \"Inicializar\". Tambi\u00e9n aparecen los bloques que nos servir\u00e1n para enviar la informaci\u00f3n a la placa. Es importante establecer a qu\u00e9 fila queremos que se env\u00ede la informaci\u00f3n. El n\u00famero 0, ya cuenta como una opci\u00f3n. Env\u00eda a la pantalla LCD los valores de temperatura y humedad cada 3 segundos. El programa los vemos en la Figura A06.12. Figura A06.12. Soluci\u00f3n A06.3","title":"A06-Sensor DHT11"},{"location":"dht11/#a06-sensor-de-temperatura-y-humedad-dht11","text":"En esta sexta actividad aprenderemos a programar el sensor de temperatura y humedad o c\u00f3mo se llama en ArduinoBlocks: DHT11. Este sensor se conecta a un puerto digital. El sensor DHT11 realmente es un sensor de temperatura y humedad. Tiene una salida de se\u00f1al digital, que funciona en un rango de temperaturas entre 0 y 50 \u00b0C, con un error de 2\u00baC y un rango de humedad entre 20 y 90%, con un error de un 5%. En la Figura A06.1 vemos su aspecto. Figura A06.1. Aspecto DHT11 En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\", como vemos en la Figura A06.2. Figura A06.2. Bloque DHT11 Antes de empezar la pr\u00e1ctica, establecemos dos variables nuevas (Figura A06.3): una para la temperatura y otra para la humedad. Figura A06.3. Declaraci\u00f3n de variables","title":"A06 - Sensor de Temperatura y humedad DHT11"},{"location":"dht11/#practica-a061","text":"En esta primera pr\u00e1ctica enviaremos los valores a la consola, es decir, los grados cent\u00edgrados y el porcentaje de humedad de la habitaci\u00f3n donde estamos. Recuerda y utiliza el bloque de programaci\u00f3n \"crear texto con\", el cual te permite a\u00f1adir diferentes mensajes en una misma l\u00ednea de texto. Env\u00eda a la consola los valores de temperatura y humedad cada 3 segundos. En la consola debe aparecer: Temperatura: X \u00baC seguido de Humedad: X %. En la Figura A06.4 vemos el programa. Figura A06.4. Soluci\u00f3n A06.1","title":"Pr\u00e1ctica A06.1"},{"location":"dht11/#practica-a062","text":"Seguidamente, trabajaremos con la herramienta Plotter. Esta es parecida a la consola, de hecho se encuentra en el desplegable de consola. Esta herramienta crea en tiempo real una estad\u00edstica de los valores obtenidos. Los bloques para programarlo, los encontraremos en el apartado 'Puerto serie'. En la Figura A06.5 vemos esto. Figura A06.5. Abrir Plotter y bloque programaci\u00f3n Env\u00eda cada 3 segundos al Serial Plotter los valores de temperatura y humedad. En la Figura A06.6 vemos el programa y el Plotter. Figura A06.6. Soluci\u00f3n A06.2 y salida en Serial Plotter Env\u00eda a la consola los valores de temperatura y humedad cada 3 segundos. En la consola debe aparecer: Temperatura: X \u00baC seguido de Humedad: X %. En la Figura A06.7 vemos el programa. Figura A06.7. Soluci\u00f3n A06.1","title":"Pr\u00e1ctica A06.2"},{"location":"dht11/#practica-a063","text":"Otra forma de poder visualizar valores es haciendo uso de pantallas externas, es decir, pantallas conectadas a la placa Easy Plug. Tal y como podemos observar en el apartado de programaci\u00f3n tenemos tres pantallas: Pantalla LCD: Es una pantalla LCD de 16 caracteres por 2 l\u00edneas con fondo azul y luz blanca. Se conecta al puerto I2C. Tiene el aspecto de la Figura A06.8. Figura A06.8. LCD1602 Pantalla OLED: El nombre es una abreviatura de \u201cOrganic Light-Emitting Diode\u201d que se traduce como \"Diodo Emisor de luz org\u00e1nico\". Una pantalla OLED es una matriz de LEDS org\u00e1nicos que se iluminan cuando emiten energ\u00eda y que tiene el aspecto de la Figura A06.9. Figura A06.9. OLED LedMatrix 8x8: Es una matriz de de 8x8 LEDS con el aspecto de la Figura A06.10. Figura A06.10. LedMatrix 8x8 En esta pr\u00e1ctica A06.3 enviaremos los mismos datos que hemos estado enviando a Consola y al Serial Plotter a nuestra pantalla LCD. As\u00ed pues, debes conectar la placa al puerto I2C. Los bloques de programaci\u00f3n de la pantalla LCD son los de la Figura A06.11. Figura A06.11. Bloques Hay que seleccionar el primero, y colocarlo en el bloque \"Inicializar\". Tambi\u00e9n aparecen los bloques que nos servir\u00e1n para enviar la informaci\u00f3n a la placa. Es importante establecer a qu\u00e9 fila queremos que se env\u00ede la informaci\u00f3n. El n\u00famero 0, ya cuenta como una opci\u00f3n. Env\u00eda a la pantalla LCD los valores de temperatura y humedad cada 3 segundos. El programa los vemos en la Figura A06.12. Figura A06.12. Soluci\u00f3n A06.3","title":"Pr\u00e1ctica A06.3"},{"location":"evitaobs/","text":"A22-Sensor infrarrojo para evitar obst\u00e1culos \u00b6 Se trata de un sensor digital que entrega una lectura de nivel TTL. El sensor est\u00e1 equipado con funci\u00f3n de ajuste de distancia con una gran adaptabilidad a la luz ambiental y es de alta precisi\u00f3n. Tiene un diodo de transmisi\u00f3n y un fototransistor de recepci\u00f3n de infrarrojos. Cuando el rayo infrarrojo lanzado por el LED transmisor encuentra un obst\u00e1culo el rayo se refleja y el fototransistor lo recibe, siendo esto procesado por un circuito comparador que detectar\u00e1 el obst\u00e1culo y el LED indicador de la placa se iluminar\u00e1. Cuando se usa para detectar l\u00edneas b\u00e1sicamente el rayo emitido se refleja si el color es blanco y no hay reflexi\u00f3n si el color es negro pudiendo as\u00ed detectar estos colores de l\u00ednea. Se puede ajustar la distancia de detecci\u00f3n con las dos resistencias variables de que est\u00e1 equipado en un rango efectivo entre 2 y 40 cm. B\u00e1sicamente se puede utilizar para evitar obst\u00e1culos y para robots seguidores de l\u00ednea bien en color blanco o bien en color negro. Su aspecto lo vemos en la Figura A22.1. Figura A22.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A22.2). Figura A22.2. Bloques Pr\u00e1ctica A22.1 \u00b6 Vamos a realizar un detector muy b\u00e1sico de obst\u00e1culos. Mostrar en una LCD el texto \u00bfObstaculo? Y el mensaje SI o NO en funci\u00f3n de que exista o no dicho obst\u00e1culo dentro del rango de detecci\u00f3n del sensor. El programa lo tenemos en la Figura A22.3. Figura A22.3. Soluci\u00f3n A22.1","title":"A22-Sensor infrarrojo para evitar obst\u00e1culos"},{"location":"evitaobs/#a22-sensor-infrarrojo-para-evitar-obstaculos","text":"Se trata de un sensor digital que entrega una lectura de nivel TTL. El sensor est\u00e1 equipado con funci\u00f3n de ajuste de distancia con una gran adaptabilidad a la luz ambiental y es de alta precisi\u00f3n. Tiene un diodo de transmisi\u00f3n y un fototransistor de recepci\u00f3n de infrarrojos. Cuando el rayo infrarrojo lanzado por el LED transmisor encuentra un obst\u00e1culo el rayo se refleja y el fototransistor lo recibe, siendo esto procesado por un circuito comparador que detectar\u00e1 el obst\u00e1culo y el LED indicador de la placa se iluminar\u00e1. Cuando se usa para detectar l\u00edneas b\u00e1sicamente el rayo emitido se refleja si el color es blanco y no hay reflexi\u00f3n si el color es negro pudiendo as\u00ed detectar estos colores de l\u00ednea. Se puede ajustar la distancia de detecci\u00f3n con las dos resistencias variables de que est\u00e1 equipado en un rango efectivo entre 2 y 40 cm. B\u00e1sicamente se puede utilizar para evitar obst\u00e1culos y para robots seguidores de l\u00ednea bien en color blanco o bien en color negro. Su aspecto lo vemos en la Figura A22.1. Figura A22.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A22.2). Figura A22.2. Bloques","title":"A22-Sensor infrarrojo para evitar obst\u00e1culos"},{"location":"evitaobs/#practica-a221","text":"Vamos a realizar un detector muy b\u00e1sico de obst\u00e1culos. Mostrar en una LCD el texto \u00bfObstaculo? Y el mensaje SI o NO en funci\u00f3n de que exista o no dicho obst\u00e1culo dentro del rango de detecci\u00f3n del sensor. El programa lo tenemos en la Figura A22.3. Figura A22.3. Soluci\u00f3n A22.1","title":"Pr\u00e1ctica A22.1"},{"location":"golpe/","text":"A11-Sensor de golpe \u00b6 A lo largo de esta pr\u00e1ctica aprenderemos a programar el sensor de golpe, que es un sensor detector de golpes, como su propio nombre indica. Por tanto, cuando se golpea puede enviar una se\u00f1al al instante. Se puede utilizar para sustituir el pulsador para encender un LED cuando golpeamos el sensor o tambi\u00e9n que cuando lo golpeamos se emita un sonido. En la Figura A11.1 vemos su aspecto. Figura A11.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A11.2). Figura A11.2. Bloques Pr\u00e1ctica A11.1 \u00b6 Al ser un sensor nuevo, antes de nada lo que haremos ser\u00e1 \"leerlo\". Es decir, enviaremos sus valores a la consola. En la Figura A11.3 vemos el programa. Figura A11.3. Soluci\u00f3n A11.1 Este sensor da c\u00f3mo salida 1 y de forma instant\u00e1nea, cuando se golpea, un 0. Un programa como el anterior va a originar que en la consola siempre tengamos el mismo valor: 1. El \"problema\" es que es una se\u00f1al tan r\u00e1pida y d\u00e9bil que no podemos visualizar su valor en la consola. Pr\u00e1ctica A11.2 \u00b6 En esta pr\u00e1ctica aprenderemos a encender un LED utilizando el sensor de golpe. Conectamos tanto el LED como el sensor de golpe a puertos digitales. Cuando damos un golpe, que el LED se encienda durante 2 segundos y que despu\u00e9s se apague. Sabemos que el sensor da 1 cuando no hay \"golpe\" y 0 cuando si hay \"golpe\". Por tanto, los valores de este sensor se mueven entre dos posibles: s\u00ed/no, verdad/falso, 1/0... As\u00ed pues, en este programa debemos preguntar si el valor que devuelve el sensor de golpe es falso, es decir, que est\u00e1 a 0 y si es as\u00ed que se encienda el LED. El programa lo vemos en la Figura A11.4. Figura A11.4. Soluci\u00f3n A11.2 Siguiendo con esta pr\u00e1ctica, realizaremos una peque\u00f1a modificaci\u00f3n e introduciremos el concepto de \"funci\u00f3n\". ArduinoBlocks tiene un apartado llamado \"funciones\" que vemos en la Figura A11.5. Figura A11.5. Men\u00fa funciones Para entender lo que es una funci\u00f3n, podemos describirlo como un conjunto de instrucciones que las agrupamos bajo un nombre. Cuando creamos una funci\u00f3n, autom\u00e1ticamente se genera un bloque de esa funci\u00f3n y se puede insertar en cualquier momento del programa para invocarla. Es una forma de agilizar y hacer mas legible la programaci\u00f3n y para que en programaciones m\u00e1s \"grandes\" nos quede todo un poco m\u00e1s ordenado. En nuestro caso agruparemos la programaci\u00f3n \"LED ON, esperar 2000 milisegundos, LED OFF\" en una funci\u00f3n llamada LUZ ON, tal y como observamos en la Figura A11.6. Figura A11.6. Funci\u00f3n LED ON","title":"A11-Sensor de golpe"},{"location":"golpe/#a11-sensor-de-golpe","text":"A lo largo de esta pr\u00e1ctica aprenderemos a programar el sensor de golpe, que es un sensor detector de golpes, como su propio nombre indica. Por tanto, cuando se golpea puede enviar una se\u00f1al al instante. Se puede utilizar para sustituir el pulsador para encender un LED cuando golpeamos el sensor o tambi\u00e9n que cuando lo golpeamos se emita un sonido. En la Figura A11.1 vemos su aspecto. Figura A11.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A11.2). Figura A11.2. Bloques","title":"A11-Sensor de golpe"},{"location":"golpe/#practica-a111","text":"Al ser un sensor nuevo, antes de nada lo que haremos ser\u00e1 \"leerlo\". Es decir, enviaremos sus valores a la consola. En la Figura A11.3 vemos el programa. Figura A11.3. Soluci\u00f3n A11.1 Este sensor da c\u00f3mo salida 1 y de forma instant\u00e1nea, cuando se golpea, un 0. Un programa como el anterior va a originar que en la consola siempre tengamos el mismo valor: 1. El \"problema\" es que es una se\u00f1al tan r\u00e1pida y d\u00e9bil que no podemos visualizar su valor en la consola.","title":"Pr\u00e1ctica A11.1"},{"location":"golpe/#practica-a112","text":"En esta pr\u00e1ctica aprenderemos a encender un LED utilizando el sensor de golpe. Conectamos tanto el LED como el sensor de golpe a puertos digitales. Cuando damos un golpe, que el LED se encienda durante 2 segundos y que despu\u00e9s se apague. Sabemos que el sensor da 1 cuando no hay \"golpe\" y 0 cuando si hay \"golpe\". Por tanto, los valores de este sensor se mueven entre dos posibles: s\u00ed/no, verdad/falso, 1/0... As\u00ed pues, en este programa debemos preguntar si el valor que devuelve el sensor de golpe es falso, es decir, que est\u00e1 a 0 y si es as\u00ed que se encienda el LED. El programa lo vemos en la Figura A11.4. Figura A11.4. Soluci\u00f3n A11.2 Siguiendo con esta pr\u00e1ctica, realizaremos una peque\u00f1a modificaci\u00f3n e introduciremos el concepto de \"funci\u00f3n\". ArduinoBlocks tiene un apartado llamado \"funciones\" que vemos en la Figura A11.5. Figura A11.5. Men\u00fa funciones Para entender lo que es una funci\u00f3n, podemos describirlo como un conjunto de instrucciones que las agrupamos bajo un nombre. Cuando creamos una funci\u00f3n, autom\u00e1ticamente se genera un bloque de esa funci\u00f3n y se puede insertar en cualquier momento del programa para invocarla. Es una forma de agilizar y hacer mas legible la programaci\u00f3n y para que en programaciones m\u00e1s \"grandes\" nos quede todo un poco m\u00e1s ordenado. En nuestro caso agruparemos la programaci\u00f3n \"LED ON, esperar 2000 milisegundos, LED OFF\" en una funci\u00f3n llamada LUZ ON, tal y como observamos en la Figura A11.6. Figura A11.6. Funci\u00f3n LED ON","title":"Pr\u00e1ctica A11.2"},{"location":"hall/","text":"A16-Sensor de campo magn\u00e9tico de efecto Hall \u00b6 El sensor de campo magn\u00e9tico se basa en el efecto Hall y puede detectar sin contacto si existe un objeto que genera un magn\u00e9tico cerca de \u00e9l. El resultado lo muestra a trav\u00e9s de su salida digital. El rango de detecci\u00f3n y la fuerza del campo magn\u00e9tico son proporcionales. Se conoce como efecto Hall a la aparici\u00f3n de un campo el\u00e9ctrico por separaci\u00f3n de cargas en el interior de un conductor por el que circula una corriente en presencia de un campo magn\u00e9tico. Su aspecto lo vemos en la Figura A16.1. Figura A16.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A16.2). Figura A16.2. Bloques Pr\u00e1ctica A16.1 \u00b6 En esta pr\u00e1ctica vamos a encender un LED cuando se detecta un campo magn\u00e9tico. Leer el valor booleano entregado por el sensor Hall y si es \u201c1\u201d encender un LED rojo y si es \u201c0\u201d mantenerlo apagado. El programa lo tenemos en la Figura A16.3. Figura A16.3. Soluci\u00f3n A16.1","title":"A16-Sensor de campo magn\u00e9tico de efecto Hall"},{"location":"hall/#a16-sensor-de-campo-magnetico-de-efecto-hall","text":"El sensor de campo magn\u00e9tico se basa en el efecto Hall y puede detectar sin contacto si existe un objeto que genera un magn\u00e9tico cerca de \u00e9l. El resultado lo muestra a trav\u00e9s de su salida digital. El rango de detecci\u00f3n y la fuerza del campo magn\u00e9tico son proporcionales. Se conoce como efecto Hall a la aparici\u00f3n de un campo el\u00e9ctrico por separaci\u00f3n de cargas en el interior de un conductor por el que circula una corriente en presencia de un campo magn\u00e9tico. Su aspecto lo vemos en la Figura A16.1. Figura A16.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A16.2). Figura A16.2. Bloques","title":"A16-Sensor de campo magn\u00e9tico de efecto Hall"},{"location":"hall/#practica-a161","text":"En esta pr\u00e1ctica vamos a encender un LED cuando se detecta un campo magn\u00e9tico. Leer el valor booleano entregado por el sensor Hall y si es \u201c1\u201d encender un LED rojo y si es \u201c0\u201d mantenerlo apagado. El programa lo tenemos en la Figura A16.3. Figura A16.3. Soluci\u00f3n A16.1","title":"Pr\u00e1ctica A16.1"},{"location":"humsuelo/","text":"A15-Sensor del nivel de humedad del suelo \u00b6 El sensor de humedad del suelo utiliza dos sondas para pasar corriente a trav\u00e9s del suelo y leer la resistencia que sirve para obtener el nivel de humedad. Si el suelo est\u00e1 muy h\u00famedo habr\u00e1 mas conducci\u00f3n de electricidad debido a la menor resistencia, mientras que un suelo seco conduce mal la electricidad porque presenta una resistencia mayor. El dispositivo se puede usar para hacer un dispositivo de riego autom\u00e1tico de plantas o jardines. Su aspecto lo vemos en la Figura A15.1. Figura A15.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A15.2). Figura A15.2. Bloques Pr\u00e1ctica A15.1 \u00b6 En esta pr\u00e1ctica vamos a leer los valores que no entrega el sensor para distintos niveles de humedad. Leer y mostrar por consola el valor de humedad entregado por el sensor totalmente seco, en una tierra con poca humedad y en una tierra con mucha humedad. El programa lo tenemos en la Figura A15.3. En lugar de tierra podemos utilizar alg\u00fan elemento que sea capaz de retener la humedad, como por ejemplo algod\u00f3n. Figura A15.3. Soluci\u00f3n A15.1","title":"A15-Sensor del nivel de humedad del suelo"},{"location":"humsuelo/#a15-sensor-del-nivel-de-humedad-del-suelo","text":"El sensor de humedad del suelo utiliza dos sondas para pasar corriente a trav\u00e9s del suelo y leer la resistencia que sirve para obtener el nivel de humedad. Si el suelo est\u00e1 muy h\u00famedo habr\u00e1 mas conducci\u00f3n de electricidad debido a la menor resistencia, mientras que un suelo seco conduce mal la electricidad porque presenta una resistencia mayor. El dispositivo se puede usar para hacer un dispositivo de riego autom\u00e1tico de plantas o jardines. Su aspecto lo vemos en la Figura A15.1. Figura A15.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A15.2). Figura A15.2. Bloques","title":"A15-Sensor del nivel de humedad del suelo"},{"location":"humsuelo/#practica-a151","text":"En esta pr\u00e1ctica vamos a leer los valores que no entrega el sensor para distintos niveles de humedad. Leer y mostrar por consola el valor de humedad entregado por el sensor totalmente seco, en una tierra con poca humedad y en una tierra con mucha humedad. El programa lo tenemos en la Figura A15.3. En lugar de tierra podemos utilizar alg\u00fan elemento que sea capaz de retener la humedad, como por ejemplo algod\u00f3n. Figura A15.3. Soluci\u00f3n A15.1","title":"Pr\u00e1ctica A15.1"},{"location":"joystick/","text":"A27-M\u00f3dulo joystick \u00b6 El m\u00f3dulo se componen de dos potenci\u00f3metros, uno para el movimiento del eje X y otro para el movimiento del eje Y asociados a entradas anal\u00f3gicas y adem\u00e1s incorpora un pulsador asociado a un pin digital. En la placa EASY PLUG existe un terminal de conexionado marcado en rojo y amarillo que son los pines A6, A7 y D2. Este mismo tipo de conexi\u00f3n la lleva el m\u00f3dulo joystick con la siguiente relaci\u00f3n de conexionado: * El eje X se conecta a A6 * El eje Y se conecta a A7 * El pulsador o eje Z se conecta a D2 Su aspecto lo vemos en la Figura A27.1. Figura A27.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A27.2). Figura A27.2. Bloques Pr\u00e1ctica A27.1 \u00b6 Vamos a mostrar por consola los valores le\u00eddos del sensor. Mostrar en la consola el valor de cada uno de los ejes en funci\u00f3n de la posici\u00f3n del mando del joystick y tambi\u00e9n indicar si se ha accionado el pulsador. El programa lo tenemos en la Figura A27.3. Figura A27.3. Soluci\u00f3n A27.1 El aspecto de la consola con los datos recibidos lo vemos en la Figura A27.4. Figura A27.4. Consola de la actividad A27.1","title":"A27-M\u00f3dulo joystick"},{"location":"joystick/#a27-modulo-joystick","text":"El m\u00f3dulo se componen de dos potenci\u00f3metros, uno para el movimiento del eje X y otro para el movimiento del eje Y asociados a entradas anal\u00f3gicas y adem\u00e1s incorpora un pulsador asociado a un pin digital. En la placa EASY PLUG existe un terminal de conexionado marcado en rojo y amarillo que son los pines A6, A7 y D2. Este mismo tipo de conexi\u00f3n la lleva el m\u00f3dulo joystick con la siguiente relaci\u00f3n de conexionado: * El eje X se conecta a A6 * El eje Y se conecta a A7 * El pulsador o eje Z se conecta a D2 Su aspecto lo vemos en la Figura A27.1. Figura A27.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A27.2). Figura A27.2. Bloques","title":"A27-M\u00f3dulo joystick"},{"location":"joystick/#practica-a271","text":"Vamos a mostrar por consola los valores le\u00eddos del sensor. Mostrar en la consola el valor de cada uno de los ejes en funci\u00f3n de la posici\u00f3n del mando del joystick y tambi\u00e9n indicar si se ha accionado el pulsador. El programa lo tenemos en la Figura A27.3. Figura A27.3. Soluci\u00f3n A27.1 El aspecto de la consola con los datos recibidos lo vemos en la Figura A27.4. Figura A27.4. Consola de la actividad A27.1","title":"Pr\u00e1ctica A27.1"},{"location":"led/","text":"A01 - LED \u00b6 En esta primera actividad con EasyPlug aprenderemos a encender un LED y a programarlo para que se apague y encienda durante un tiempo determinado. En la Figura A01.1 vemos el aspecto del componente. Figura A01.1. LED El LED es un actuador y por tanto, lo encontraremos en el apartado de actuadores, tal y como observamos en la Figura A01.2. Figura A01.2. Bloque LED Si necesitamos programar un tiempo de retardo, deberemos ir al apartado de \"Tiempo\", tal y como observamos en la Figura A01.3. Figura A01.3. Bloques tiempo Pr\u00e1ctica A01.1 \u00b6 \u2022 Encendre un LED. En la Figura A01.4 vemos como iniciamos el programa arrastrando los bloques a la zona de programa desde los men\u00fa. Figura A01.4. Programa inicial LED En el ejemplo la espera en realidad no sirve para mucho y el LED permanecer\u00e1 a nuestros ojos siempre encendido. Pr\u00e1ctica A01.2 \u00b6 \u2022 Encendre un LED, esperar 3 segundos, apagar el LED y esperar otros 3 segundos. En la Figura A01.5 vemos el programa resuelto. Figura A01.5. Programa parpadeo LED Deduce y comprueba el efecto de no poner el tiempo de retardo tras apagar el LED. Pr\u00e1ctica A01.3 \u00b6 \u2022 Repetir la acci\u00f3n de la pr\u00e1ctica A01.2 cinco veces. En la Figura A01.6 vemos el programa resuelto. En la parte derecha de la misma Figura vemos donde se localiza el bloque repetir. Figura A01.6. Repetir parpadeo LED Pr\u00e1ctica A01.4 \u00b6 \u2022 Repetir la acci\u00f3n de la pr\u00e1ctica A01.3 esperando un segundo entre repeticiones. En la Figura A01.7 vemos el programa resuelto. Figura A01.7. Repetir parpadeo LED con espera Pr\u00e1ctica A01.5 \u00b6 Para esta pr\u00e1ctica conectamos dos LEDS a la placa, LED 1 en D5 y LED 2 en D7. \u2022 Se enciende LED 1 (D5) esperamos 2 segundos, se apaga el LED 1 y se enciende el LED 2 (D7) y esperamos 2 segundos y se apaga. Esta acci\u00f3n se repite 3 veces. En la Figura A01.8 tenemos la soluci\u00f3n. Figura A01.8. Encender y apagar dos LEDs","title":"A01-LED"},{"location":"led/#a01-led","text":"En esta primera actividad con EasyPlug aprenderemos a encender un LED y a programarlo para que se apague y encienda durante un tiempo determinado. En la Figura A01.1 vemos el aspecto del componente. Figura A01.1. LED El LED es un actuador y por tanto, lo encontraremos en el apartado de actuadores, tal y como observamos en la Figura A01.2. Figura A01.2. Bloque LED Si necesitamos programar un tiempo de retardo, deberemos ir al apartado de \"Tiempo\", tal y como observamos en la Figura A01.3. Figura A01.3. Bloques tiempo","title":"A01 - LED"},{"location":"led/#practica-a011","text":"\u2022 Encendre un LED. En la Figura A01.4 vemos como iniciamos el programa arrastrando los bloques a la zona de programa desde los men\u00fa. Figura A01.4. Programa inicial LED En el ejemplo la espera en realidad no sirve para mucho y el LED permanecer\u00e1 a nuestros ojos siempre encendido.","title":"Pr\u00e1ctica A01.1"},{"location":"led/#practica-a012","text":"\u2022 Encendre un LED, esperar 3 segundos, apagar el LED y esperar otros 3 segundos. En la Figura A01.5 vemos el programa resuelto. Figura A01.5. Programa parpadeo LED Deduce y comprueba el efecto de no poner el tiempo de retardo tras apagar el LED.","title":"Pr\u00e1ctica A01.2"},{"location":"led/#practica-a013","text":"\u2022 Repetir la acci\u00f3n de la pr\u00e1ctica A01.2 cinco veces. En la Figura A01.6 vemos el programa resuelto. En la parte derecha de la misma Figura vemos donde se localiza el bloque repetir. Figura A01.6. Repetir parpadeo LED","title":"Pr\u00e1ctica A01.3"},{"location":"led/#practica-a014","text":"\u2022 Repetir la acci\u00f3n de la pr\u00e1ctica A01.3 esperando un segundo entre repeticiones. En la Figura A01.7 vemos el programa resuelto. Figura A01.7. Repetir parpadeo LED con espera","title":"Pr\u00e1ctica A01.4"},{"location":"led/#practica-a015","text":"Para esta pr\u00e1ctica conectamos dos LEDS a la placa, LED 1 en D5 y LED 2 en D7. \u2022 Se enciende LED 1 (D5) esperamos 2 segundos, se apaga el LED 1 y se enciende el LED 2 (D7) y esperamos 2 segundos y se apaga. Esta acci\u00f3n se repite 3 veces. En la Figura A01.8 tenemos la soluci\u00f3n. Figura A01.8. Encender y apagar dos LEDs","title":"Pr\u00e1ctica A01.5"},{"location":"led_PWM/","text":"A02 - Control por PWM de la luminosidad de un LED \u00b6 Siguiendo con el uso de los LEDs, controlaremos la intensidad de un LED utilizando el PWM, que es el acr\u00f3nimo de Pulse Width Modulation y significa Modulaci\u00f3n por Anchura de Pulsos. Las patillas de salida de Arduino s\u00f3lo tienen dos estados posibles: ON y OFF, es decir, una corresponde a una salida de 5V (ON) y otra de 0V (OFF). Si s\u00f3lo hacemos uso de estas dos condiciones, s\u00f3lo podemos realizar actividades como encender y apagar un LED. Gracias al PWM podemos programar un rango de valores de 0 a 255 que haga variar estas tensiones entre los 0V y los 5V. De esta forma podemos controlar la intensidad con la que luce un LED. Encontramos el bloque de programaci\u00f3n en el apartado de actuadores, tal y como observamos en la Figura A02.1. Figura A02.1. Bloque PWM LED Pr\u00e1ctica A02.1 \u00b6 \u2022 Programamos el LED a un valor de 255 para que se encienda al m\u00e1ximo de iluminaci\u00f3n y despu\u00e9s de un segundo, que se apague. Es decir, ponemos el valor a 0. En la Figura A02.2 tenemos la soluci\u00f3n. Figura A02.2. Encender y apagar LED con bloque PWM Pr\u00e1ctica A02.2 \u00b6 Hacer que la intensidad del LEDde la pr\u00e1ctica A02.1 cambie. \u2022 Cada 2000 milisegundos la intensidad del LED debe cambiar, aumentando de 0 a 100 y 255. En la Figura A02.3 tenemos la soluci\u00f3n. Figura A02.3. Cambiar intensidad LED con bloque PWM Pr\u00e1ctica A02.3 \u00b6 Para poder programar de una forma m\u00e1s pr\u00e1ctica y efectiva el PWM, podemos hacer uso del bloque \u201cContar\u201d situado en el apartado de \"Control\", como vemos en la Figura A02.4. \u00c9ste permite contar desde un determinado n\u00famero hasta otro. A su vez, podemos decidir con qu\u00e9 frecuencia, es decir, cada dos n\u00fameros o cada diez. Figura A02.4. Bloque contar En este bloque existe un nuevo concepto que es muy utilizado en programaci\u00f3n: las variables. En esta actividad las utilizaremos de forma muy r\u00e1pida, pero m\u00e1s adelante ser\u00e1n herramientas necesarias para que nuestra programaci\u00f3n tenga sentido. Justamente, en nuestro bloque la variable se llama \"i\". \u2022 La intensidad del LED debe aumentar de 25 en 25, desde 0 a 255. En la Figura A02.5 vemos el programa. Figura A02.5. Cambiar intensidad LED con bloque PWM El bloque con el nombre de la variable lo vamos a encontrar en \u201cVariables\u201d.","title":"A02-Control PWM luminosidad LED"},{"location":"led_PWM/#a02-control-por-pwm-de-la-luminosidad-de-un-led","text":"Siguiendo con el uso de los LEDs, controlaremos la intensidad de un LED utilizando el PWM, que es el acr\u00f3nimo de Pulse Width Modulation y significa Modulaci\u00f3n por Anchura de Pulsos. Las patillas de salida de Arduino s\u00f3lo tienen dos estados posibles: ON y OFF, es decir, una corresponde a una salida de 5V (ON) y otra de 0V (OFF). Si s\u00f3lo hacemos uso de estas dos condiciones, s\u00f3lo podemos realizar actividades como encender y apagar un LED. Gracias al PWM podemos programar un rango de valores de 0 a 255 que haga variar estas tensiones entre los 0V y los 5V. De esta forma podemos controlar la intensidad con la que luce un LED. Encontramos el bloque de programaci\u00f3n en el apartado de actuadores, tal y como observamos en la Figura A02.1. Figura A02.1. Bloque PWM LED","title":"A02 - Control por PWM de la luminosidad de un LED"},{"location":"led_PWM/#practica-a021","text":"\u2022 Programamos el LED a un valor de 255 para que se encienda al m\u00e1ximo de iluminaci\u00f3n y despu\u00e9s de un segundo, que se apague. Es decir, ponemos el valor a 0. En la Figura A02.2 tenemos la soluci\u00f3n. Figura A02.2. Encender y apagar LED con bloque PWM","title":"Pr\u00e1ctica A02.1"},{"location":"led_PWM/#practica-a022","text":"Hacer que la intensidad del LEDde la pr\u00e1ctica A02.1 cambie. \u2022 Cada 2000 milisegundos la intensidad del LED debe cambiar, aumentando de 0 a 100 y 255. En la Figura A02.3 tenemos la soluci\u00f3n. Figura A02.3. Cambiar intensidad LED con bloque PWM","title":"Pr\u00e1ctica A02.2"},{"location":"led_PWM/#practica-a023","text":"Para poder programar de una forma m\u00e1s pr\u00e1ctica y efectiva el PWM, podemos hacer uso del bloque \u201cContar\u201d situado en el apartado de \"Control\", como vemos en la Figura A02.4. \u00c9ste permite contar desde un determinado n\u00famero hasta otro. A su vez, podemos decidir con qu\u00e9 frecuencia, es decir, cada dos n\u00fameros o cada diez. Figura A02.4. Bloque contar En este bloque existe un nuevo concepto que es muy utilizado en programaci\u00f3n: las variables. En esta actividad las utilizaremos de forma muy r\u00e1pida, pero m\u00e1s adelante ser\u00e1n herramientas necesarias para que nuestra programaci\u00f3n tenga sentido. Justamente, en nuestro bloque la variable se llama \"i\". \u2022 La intensidad del LED debe aumentar de 25 en 25, desde 0 a 255. En la Figura A02.5 vemos el programa. Figura A02.5. Cambiar intensidad LED con bloque PWM El bloque con el nombre de la variable lo vamos a encontrar en \u201cVariables\u201d.","title":"Pr\u00e1ctica A02.3"},{"location":"llama/","text":"A20-Sensor de llama \u00b6 Es un sensor digital que puede detectar fuego o cualquier otra llama cuya luz tenga una longitud de onda entre 760 nm y 1100 nm, es decir, desde el rojo visible de las llamas hasta el infrarrojo de las mismas. Un robot contra incendios usar\u00e1 un detector de este tipo como sonda detectora de la fuente del fuego. Sus principales caracter\u00edsticas son: Alimentaci\u00f3n: 3.3V a 5V Ancho de banda espectral: 760nm a 1100nm Temperatura de trabajo: -25 \u00b0C a 85 \u00b0C El potenci\u00f3metro sirve para ajustar la sensibilidad del sensor. Su aspecto lo vemos en la Figura A20.1. Figura A20.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A20.2). Figura A20.2. Bloques Pr\u00e1ctica A20.1 \u00b6 Vamos a detectar la llama de un encendedor a gas. Mostrar en una LCD el mensaje \u201cLLAMA DETECTADA\u201d cuando esto ocurra y mientras tanto el mensaje \u201cNo hay peligro\u201d. El programa lo tenemos en la Figura A20.3. Figura A20.3. Soluci\u00f3n A20.1 Pr\u00e1ctica A20.2 \u00b6 Se propone como actividad mejorar la anterior haciendo que cuando se detecta llama tambi\u00e9n se emite un sonido tipo sirena y que un LED parpadee. Adem\u00e1s a\u00f1adiremos dos diodos LED que se encender\u00e1n y apagar\u00e1n de forma alternativa mientras suena la alarma.","title":"A20-Sensor de llama"},{"location":"llama/#a20-sensor-de-llama","text":"Es un sensor digital que puede detectar fuego o cualquier otra llama cuya luz tenga una longitud de onda entre 760 nm y 1100 nm, es decir, desde el rojo visible de las llamas hasta el infrarrojo de las mismas. Un robot contra incendios usar\u00e1 un detector de este tipo como sonda detectora de la fuente del fuego. Sus principales caracter\u00edsticas son: Alimentaci\u00f3n: 3.3V a 5V Ancho de banda espectral: 760nm a 1100nm Temperatura de trabajo: -25 \u00b0C a 85 \u00b0C El potenci\u00f3metro sirve para ajustar la sensibilidad del sensor. Su aspecto lo vemos en la Figura A20.1. Figura A20.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A20.2). Figura A20.2. Bloques","title":"A20-Sensor de llama"},{"location":"llama/#practica-a201","text":"Vamos a detectar la llama de un encendedor a gas. Mostrar en una LCD el mensaje \u201cLLAMA DETECTADA\u201d cuando esto ocurra y mientras tanto el mensaje \u201cNo hay peligro\u201d. El programa lo tenemos en la Figura A20.3. Figura A20.3. Soluci\u00f3n A20.1","title":"Pr\u00e1ctica A20.1"},{"location":"llama/#practica-a202","text":"Se propone como actividad mejorar la anterior haciendo que cuando se detecta llama tambi\u00e9n se emite un sonido tipo sirena y que un LED parpadee. Adem\u00e1s a\u00f1adiremos dos diodos LED que se encender\u00e1n y apagar\u00e1n de forma alternativa mientras suena la alarma.","title":"Pr\u00e1ctica A20.2"},{"location":"lm35/","text":"A19-Sensor de temperatura LM35 \u00b6 El LM35D es un sensor anal\u00f3gico de temperatura que tiene un rango de medida que va desde los -55\u00baC hasta los 150\u00b0C y una sensibilidad de 10 mV/\u00baC. Es decir, su salida es lineal y cada grado Celsius equivale a 10 mV, por lo tanto: 150\u00b0C = 1500 mV -55\u00b0C = -550 mV Sus principales caracter\u00edsticas son: Est\u00e1 calibrado para dar la medici\u00f3n en Celsius Factor de escala lineal de \u00b1 10 mV/\u00b0C Precisi\u00f3n de 0.5 \u00b0C (a 25\u00b0C) Adecuado para aplicaciones que trabajan en remoto Su aspecto lo vemos en la Figura A19.1. Figura A19.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A19.2). Figura A19.2. Bloques Pr\u00e1ctica A19.1 \u00b6 Vamos a medir la temperatura ambiente de una habitaci\u00f3n. Mostrar en una LCD la temperatura medida por un LM35. El programa lo tenemos en la Figura A19.3. Figura A19.3. Soluci\u00f3n A19.1","title":"A19-Sensor de temperatura LM35"},{"location":"lm35/#a19-sensor-de-temperatura-lm35","text":"El LM35D es un sensor anal\u00f3gico de temperatura que tiene un rango de medida que va desde los -55\u00baC hasta los 150\u00b0C y una sensibilidad de 10 mV/\u00baC. Es decir, su salida es lineal y cada grado Celsius equivale a 10 mV, por lo tanto: 150\u00b0C = 1500 mV -55\u00b0C = -550 mV Sus principales caracter\u00edsticas son: Est\u00e1 calibrado para dar la medici\u00f3n en Celsius Factor de escala lineal de \u00b1 10 mV/\u00b0C Precisi\u00f3n de 0.5 \u00b0C (a 25\u00b0C) Adecuado para aplicaciones que trabajan en remoto Su aspecto lo vemos en la Figura A19.1. Figura A19.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A19.2). Figura A19.2. Bloques","title":"A19-Sensor de temperatura LM35"},{"location":"lm35/#practica-a191","text":"Vamos a medir la temperatura ambiente de una habitaci\u00f3n. Mostrar en una LCD la temperatura medida por un LM35. El programa lo tenemos en la Figura A19.3. Figura A19.3. Soluci\u00f3n A19.1","title":"Pr\u00e1ctica A19.1"},{"location":"matriz/","text":"A07-Matriz de 8x8 LEDs \u00b6 En esta pr\u00e1ctica el objetivo es conocer la LEDMatrix 8x8 o tambi\u00e9n llamada matriz de LEDs. La matriz de LEDs es una pantalla peque\u00f1a que tiene 64 LEDs con el aspecto de la Figura A07.1 y se conecta al puerto de comunicaci\u00f3n I2C. En esta pantalla podemos programar diferentes s\u00edmbolos o elementos, como: caras, iconos, letras... Hay opciones predise\u00f1adas desde ArduinoBlocks y tambi\u00e9n, existe la opci\u00f3n de crearlos personalizados. Figura A07.1. Aspecto matriz 8x8 En el apartado de bloques de programaci\u00f3n, se encuentra en \"LedMatrix 8x8\" (Figura A07.2). Existen diferentes opciones de programaci\u00f3n, seg\u00fan nuestro objetivo. Figura A07.2. Bloques La primera tarea que debemos realizar cuando queremos hacer uso de la pantalla, es inicializarla. En la Figura A07.3 el primer bloque vemos que pone: inicializar I2C. Figura A07.3. Inicializar Hay una pesta\u00f1a que nos deja escoger distintos n\u00fameros. Esto significa que podemos utilizar ocho diferentes haciendo uso de un Hub I2C como el de la Figura A07.4. Un Hub ser\u00eda como un \"ladr\u00f3n\", que nos permite conectar varios dispositivos a la vez. \u00c9ste se conecta al puerto I2C. Figura A07.4. Hub I2C Pr\u00e1ctica A07.1 \u00b6 En esta pr\u00e1ctica introduciremos el uso de la LedMatrix. Lo que haremos es enviar un programa sencillo: La pantalla LedMatrix muestra una flecha hacia arriba, y despu\u00e9s de dos segundos, muestra una flecha hacia abajo. Vemos el programa en la Figura A07.5. Figura A07.5. Soluci\u00f3n A07.1 Pr\u00e1ctica A07.2 \u00b6 En esta pr\u00e1ctica introduciremos otra forma de dise\u00f1ar s\u00edmbolos en la pantalla y tambi\u00e9n haremos uso de un pulsador. Cuando se pulse el pulsador, en la pantalla debe aparecer un s\u00edmbolo personalizado durante dos segundos y despu\u00e9s otro distinto. Vemos el programa en la Figura A07.6. Figura A07.6. Soluci\u00f3n A07.2 Pr\u00e1ctica A07.3 \u00b6 En esta tercera pr\u00e1ctica recrearemos el famoso y conocido juego \"Piedra, papel, tijera\". Esta vez, aprenderemos otra forma de crear nuestros s\u00edmbolos personalizados. Tambi\u00e9n utilizaremos el pulsador para activar el juego y aprenderemos a crear una variable que elija aleatoriamente uno de los tres s\u00edmbolos del juego. Cuando se pulse el pulsador, la pantalla muestra, de forma aleatoria, uno de los tres s\u00edmbolos: piedra, papel o tijeras. Lo primero que vamos a hacer es crear los tres s\u00edmbolos: utilizando el \"Bitmap\". Para seleccionar los LEDs que queremos en estado ON, debemos dar los siguientes pasos: Nos dirigimos a herramientas y escogemos seg\u00fan la Figura A07.7. Tambi\u00e9n podemos hacer clic en el bot\u00f3n derecho del rat\u00f3n sobre el bloque de programaci\u00f3n, escoger la opci\u00f3n \"ayuda\". De cualquiera de las formas se nos abre otra pesta\u00f1a en la que podemos ver un simulador de la pantalla. Figura A07.7. Acceso LedMatrix - Bipmap Editor Seleccionamos cada LED que queremos encender, as\u00ed se nos devolver\u00e1 de color rojo. Por \u00faltimo, seleccionamos \"Copy data\" y dentro del cuadradito que est\u00e1 al lado de \"bitmap\", hacemos Ctrl+V y se nos engancha en c\u00f3digo binario los LEDs que hemos seleccionado. Creamos, las im\u00e1genes que vemos en la Figura A07.8. Figura A07.8. Creaci\u00f3n de las im\u00e1genes Para realizar esta pr\u00e1ctica, vamos a necesitar crear una variable que llamaremos \"Juego\". Esta variable le asignamos tres n\u00fameros aleatorios, del 1 al 3. De este modo, asignaremos a cada n\u00famero un s\u00edmbolo. Es decir, que 1 es piedra, 2 es papel y 3 es tijeras. El bloque de programaci\u00f3n: \"entero aleatorio de x a x\" lo encontramos en \"Matem\u00e1ticas\" (Figura A07.9). \u00c9ste nos permite escoger aleatoriamente el rango de n\u00fameros que nosotros establecemos. Figura A07.9. Bloque entero aleatorio de x a x As\u00ed pues, crearemos la variable \"juego\" estableciendo estos valores de 1 a 3. Una vez tenemos la variable creada y los s\u00edmbolos, debemos seleccionar la opci\u00f3n de condicionales en el bloque de l\u00f3gica, para establecer que si la variable \"juego\" es igual a 1, sea piedra. En cambio, si es igual a 2, sea papel o si es igual a 3 sea tijeras. Vemos el programa en la Figura A07.10 para crear el juego. Figura A07.10. Soluci\u00f3n A07.3 De este modo, cada vez que el jugador pulse el pulsador, el programa de forma aleatoria escoger\u00e1 un n\u00famero aleatorio entre 1, 2 y 3. Cuando lo elija, la pantalla mostrar\u00e1 el s\u00edmbolo que corresponde al n\u00famero seleccionado aleatoriamente. En la Figura A07.11 se muestran dos jugadores con el mismo programa, o lo que es lo mismo, practicando el juego. Figura A07.11. Jugando a piedra, papel,tijera","title":"A07-Matriz de 8x8 LEDs"},{"location":"matriz/#a07-matriz-de-8x8-leds","text":"En esta pr\u00e1ctica el objetivo es conocer la LEDMatrix 8x8 o tambi\u00e9n llamada matriz de LEDs. La matriz de LEDs es una pantalla peque\u00f1a que tiene 64 LEDs con el aspecto de la Figura A07.1 y se conecta al puerto de comunicaci\u00f3n I2C. En esta pantalla podemos programar diferentes s\u00edmbolos o elementos, como: caras, iconos, letras... Hay opciones predise\u00f1adas desde ArduinoBlocks y tambi\u00e9n, existe la opci\u00f3n de crearlos personalizados. Figura A07.1. Aspecto matriz 8x8 En el apartado de bloques de programaci\u00f3n, se encuentra en \"LedMatrix 8x8\" (Figura A07.2). Existen diferentes opciones de programaci\u00f3n, seg\u00fan nuestro objetivo. Figura A07.2. Bloques La primera tarea que debemos realizar cuando queremos hacer uso de la pantalla, es inicializarla. En la Figura A07.3 el primer bloque vemos que pone: inicializar I2C. Figura A07.3. Inicializar Hay una pesta\u00f1a que nos deja escoger distintos n\u00fameros. Esto significa que podemos utilizar ocho diferentes haciendo uso de un Hub I2C como el de la Figura A07.4. Un Hub ser\u00eda como un \"ladr\u00f3n\", que nos permite conectar varios dispositivos a la vez. \u00c9ste se conecta al puerto I2C. Figura A07.4. Hub I2C","title":"A07-Matriz de 8x8 LEDs"},{"location":"matriz/#practica-a071","text":"En esta pr\u00e1ctica introduciremos el uso de la LedMatrix. Lo que haremos es enviar un programa sencillo: La pantalla LedMatrix muestra una flecha hacia arriba, y despu\u00e9s de dos segundos, muestra una flecha hacia abajo. Vemos el programa en la Figura A07.5. Figura A07.5. Soluci\u00f3n A07.1","title":"Pr\u00e1ctica A07.1"},{"location":"matriz/#practica-a072","text":"En esta pr\u00e1ctica introduciremos otra forma de dise\u00f1ar s\u00edmbolos en la pantalla y tambi\u00e9n haremos uso de un pulsador. Cuando se pulse el pulsador, en la pantalla debe aparecer un s\u00edmbolo personalizado durante dos segundos y despu\u00e9s otro distinto. Vemos el programa en la Figura A07.6. Figura A07.6. Soluci\u00f3n A07.2","title":"Pr\u00e1ctica A07.2"},{"location":"matriz/#practica-a073","text":"En esta tercera pr\u00e1ctica recrearemos el famoso y conocido juego \"Piedra, papel, tijera\". Esta vez, aprenderemos otra forma de crear nuestros s\u00edmbolos personalizados. Tambi\u00e9n utilizaremos el pulsador para activar el juego y aprenderemos a crear una variable que elija aleatoriamente uno de los tres s\u00edmbolos del juego. Cuando se pulse el pulsador, la pantalla muestra, de forma aleatoria, uno de los tres s\u00edmbolos: piedra, papel o tijeras. Lo primero que vamos a hacer es crear los tres s\u00edmbolos: utilizando el \"Bitmap\". Para seleccionar los LEDs que queremos en estado ON, debemos dar los siguientes pasos: Nos dirigimos a herramientas y escogemos seg\u00fan la Figura A07.7. Tambi\u00e9n podemos hacer clic en el bot\u00f3n derecho del rat\u00f3n sobre el bloque de programaci\u00f3n, escoger la opci\u00f3n \"ayuda\". De cualquiera de las formas se nos abre otra pesta\u00f1a en la que podemos ver un simulador de la pantalla. Figura A07.7. Acceso LedMatrix - Bipmap Editor Seleccionamos cada LED que queremos encender, as\u00ed se nos devolver\u00e1 de color rojo. Por \u00faltimo, seleccionamos \"Copy data\" y dentro del cuadradito que est\u00e1 al lado de \"bitmap\", hacemos Ctrl+V y se nos engancha en c\u00f3digo binario los LEDs que hemos seleccionado. Creamos, las im\u00e1genes que vemos en la Figura A07.8. Figura A07.8. Creaci\u00f3n de las im\u00e1genes Para realizar esta pr\u00e1ctica, vamos a necesitar crear una variable que llamaremos \"Juego\". Esta variable le asignamos tres n\u00fameros aleatorios, del 1 al 3. De este modo, asignaremos a cada n\u00famero un s\u00edmbolo. Es decir, que 1 es piedra, 2 es papel y 3 es tijeras. El bloque de programaci\u00f3n: \"entero aleatorio de x a x\" lo encontramos en \"Matem\u00e1ticas\" (Figura A07.9). \u00c9ste nos permite escoger aleatoriamente el rango de n\u00fameros que nosotros establecemos. Figura A07.9. Bloque entero aleatorio de x a x As\u00ed pues, crearemos la variable \"juego\" estableciendo estos valores de 1 a 3. Una vez tenemos la variable creada y los s\u00edmbolos, debemos seleccionar la opci\u00f3n de condicionales en el bloque de l\u00f3gica, para establecer que si la variable \"juego\" es igual a 1, sea piedra. En cambio, si es igual a 2, sea papel o si es igual a 3 sea tijeras. Vemos el programa en la Figura A07.10 para crear el juego. Figura A07.10. Soluci\u00f3n A07.3 De este modo, cada vez que el jugador pulse el pulsador, el programa de forma aleatoria escoger\u00e1 un n\u00famero aleatorio entre 1, 2 y 3. Cuando lo elija, la pantalla mostrar\u00e1 el s\u00edmbolo que corresponde al n\u00famero seleccionado aleatoriamente. En la Figura A07.11 se muestran dos jugadores con el mismo programa, o lo que es lo mismo, practicando el juego. Figura A07.11. Jugando a piedra, papel,tijera","title":"Pr\u00e1ctica A07.3"},{"location":"mq135/","text":"A28-Sensor MQ-135 \u00b6 El MQ-135 dispone de una l\u00e1mina de SnO2 como material sensible a los gases y basa su funcionamiento en que el SnO2 tiene baja conductividad el\u00e9ctrica en el aire limpio. Su funcionamiento es muy sencillo, seg\u00fan aumente la cantidad de contaminantes en el aire tambi\u00e9n aumentar\u00e1 su conductividad el\u00e9ctrica y viceversa. El MQ-135 tiene una sensibilidad alta a la presencia de amoniaco, sulfuros, vapores de benceno, humo y otros gases nocivos para la salud. El m\u00f3dulo dispone de una resistencia ajustable que permite regular la sensibilidad del mismo. En el datasheet del sensor tenemos un \u00e1baco de curvas (Figura A28.1) que nos muestra las caracter\u00edsticas t\u00edpicas de sensibilidad del MQ-135 para varios gases. Las curvas se dan a una temperatura de 20\u00baC, una humedad del 65% bajo una concentraci\u00f3n de O2 del 21% y una RL=20k\u03a9 con: Ro: resistencia del sensor a 100 ppm de NH3 en aire limpio. Rs: resistencia del sensor a varias concentraciones de gases. Figura A28.1. Curvas sensibilidad MQ-135 El sensor requiere para su funcionamiento un calentamiento previo de unos 30 segundos y cuando se utiliza por primera vez se recomienda que este sea de entre 8 y 12 horas para que el calor que se genera durante este tiempo queme los residuos del proceso de fabricaci\u00f3n. No es recomendable tocar el sensor una vez conectado ya que puede quemar. Los m\u00f3dulos MQ son sensibles a m\u00e1s de un gas y en diferentes proporciones por lo que no sirven para identificar la presencia de un gas especifico. Dado que el sensor va a estar en ambientes con presencia de gases que pueden ser inflamables el mismo se encierra en una c\u00e1psula de dos capas de malla de acero inoxidable que asegura que el elemento calefactor interno no cause una explosi\u00f3n. Esta malla sirve tambi\u00e9n de filtro para las part\u00edculas en suspensi\u00f3n evitando que entren al interior de la c\u00e1mara y que solamente penetren a ella los gases. El sistema calefactor se realiza mediante una bobina de n\u00edquel cromado que es la que se recubre del di\u00f3xido de esta\u00f1o sensible a gases combustibles. Su aspecto lo vemos en la Figura A28.2. Figura A28.2. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A28.3). Figura A28.3. Bloques Pr\u00e1ctica A28.1 \u00b6 Vamos a medir la presencia de gases en el ambiente de una habitaci\u00f3n. Mostrar en la consola mensajes relativos a la calidad del aire de una habitaci\u00f3n en funci\u00f3n de que se detecte un determinado nivel de presencia de gases en la misma. El bloque nos entrega la medida en % y vamos a estimar que si el valor medido est\u00e1 por debajo del 20% la calidad del aire es buena, si est\u00e1 entre e 21% y el 60% es aceptable y que si el porcentaje supera el 60% la calidad del aire es mala. Asociaremos a cada grupo de valores los mensajes de \u201cNo hay que tomar ninguna acci\u00f3n\u201d, \u201cEs conveniente ventilar la sala\u201d y \u201cPeligro, desalojar y ventilar la sala\u201d. El programa lo tenemos en la Figura A28.4. Figura A28.4. Soluci\u00f3n A28.1 El aspecto de la consola con los datos recibidos lo vemos en la Figura A28.5. Figura A28.5. Consola de la actividad A28.1","title":"A28-Sensor MQ-135"},{"location":"mq135/#a28-sensor-mq-135","text":"El MQ-135 dispone de una l\u00e1mina de SnO2 como material sensible a los gases y basa su funcionamiento en que el SnO2 tiene baja conductividad el\u00e9ctrica en el aire limpio. Su funcionamiento es muy sencillo, seg\u00fan aumente la cantidad de contaminantes en el aire tambi\u00e9n aumentar\u00e1 su conductividad el\u00e9ctrica y viceversa. El MQ-135 tiene una sensibilidad alta a la presencia de amoniaco, sulfuros, vapores de benceno, humo y otros gases nocivos para la salud. El m\u00f3dulo dispone de una resistencia ajustable que permite regular la sensibilidad del mismo. En el datasheet del sensor tenemos un \u00e1baco de curvas (Figura A28.1) que nos muestra las caracter\u00edsticas t\u00edpicas de sensibilidad del MQ-135 para varios gases. Las curvas se dan a una temperatura de 20\u00baC, una humedad del 65% bajo una concentraci\u00f3n de O2 del 21% y una RL=20k\u03a9 con: Ro: resistencia del sensor a 100 ppm de NH3 en aire limpio. Rs: resistencia del sensor a varias concentraciones de gases. Figura A28.1. Curvas sensibilidad MQ-135 El sensor requiere para su funcionamiento un calentamiento previo de unos 30 segundos y cuando se utiliza por primera vez se recomienda que este sea de entre 8 y 12 horas para que el calor que se genera durante este tiempo queme los residuos del proceso de fabricaci\u00f3n. No es recomendable tocar el sensor una vez conectado ya que puede quemar. Los m\u00f3dulos MQ son sensibles a m\u00e1s de un gas y en diferentes proporciones por lo que no sirven para identificar la presencia de un gas especifico. Dado que el sensor va a estar en ambientes con presencia de gases que pueden ser inflamables el mismo se encierra en una c\u00e1psula de dos capas de malla de acero inoxidable que asegura que el elemento calefactor interno no cause una explosi\u00f3n. Esta malla sirve tambi\u00e9n de filtro para las part\u00edculas en suspensi\u00f3n evitando que entren al interior de la c\u00e1mara y que solamente penetren a ella los gases. El sistema calefactor se realiza mediante una bobina de n\u00edquel cromado que es la que se recubre del di\u00f3xido de esta\u00f1o sensible a gases combustibles. Su aspecto lo vemos en la Figura A28.2. Figura A28.2. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A28.3). Figura A28.3. Bloques","title":"A28-Sensor MQ-135"},{"location":"mq135/#practica-a281","text":"Vamos a medir la presencia de gases en el ambiente de una habitaci\u00f3n. Mostrar en la consola mensajes relativos a la calidad del aire de una habitaci\u00f3n en funci\u00f3n de que se detecte un determinado nivel de presencia de gases en la misma. El bloque nos entrega la medida en % y vamos a estimar que si el valor medido est\u00e1 por debajo del 20% la calidad del aire es buena, si est\u00e1 entre e 21% y el 60% es aceptable y que si el porcentaje supera el 60% la calidad del aire es mala. Asociaremos a cada grupo de valores los mensajes de \u201cNo hay que tomar ninguna acci\u00f3n\u201d, \u201cEs conveniente ventilar la sala\u201d y \u201cPeligro, desalojar y ventilar la sala\u201d. El programa lo tenemos en la Figura A28.4. Figura A28.4. Soluci\u00f3n A28.1 El aspecto de la consola con los datos recibidos lo vemos en la Figura A28.5. Figura A28.5. Consola de la actividad A28.1","title":"Pr\u00e1ctica A28.1"},{"location":"nivelagua/","text":"A14-Detector de nivel agua \u00b6 Este sensor est\u00e1 especialmente dise\u00f1ado para identificar el nivel de agua y para detectar fugas de agua o detectar agua de lluvia. Es posible medir el nivel a trav\u00e9s de una serie de pistas expuestas. Realiza una conversi\u00f3n directa y proporcional entre la cantidad de agua y la salida anal\u00f3gica. Su aspecto lo vemos en la Figura A14.1. Figura A14.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A14.2). Figura A14.2. Bloques Pr\u00e1ctica A14.1 \u00b6 Vamos en primer lugar a leer los valores que da el sensor y mostrarlos por consola. Leer y mostrar los valores cuando el sensor est\u00e1 al aire y cuando se va introduciendo en el agua hasta llegar al m\u00e1ximo valor. El programa lo tenemos en la Figura A14.3. Figura A14.3. Soluci\u00f3n A14.1 Pr\u00e1ctica A14.2 \u00b6 En esta pr\u00e1ctica vamos a realizar una alarma \u00f3ptico-ac\u00fastica que nos indique que tenemos una fuga de agua. Cuando el sensor de agua detecte un nivel del 10% se accionar\u00e1 la alarma de manera intermitente cada 5 segundos. El programa lo tenemos en la Figura A14.4. Figura A14.4. Soluci\u00f3n A14.2","title":"A14-Detector de nivel agua"},{"location":"nivelagua/#a14-detector-de-nivel-agua","text":"Este sensor est\u00e1 especialmente dise\u00f1ado para identificar el nivel de agua y para detectar fugas de agua o detectar agua de lluvia. Es posible medir el nivel a trav\u00e9s de una serie de pistas expuestas. Realiza una conversi\u00f3n directa y proporcional entre la cantidad de agua y la salida anal\u00f3gica. Su aspecto lo vemos en la Figura A14.1. Figura A14.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A14.2). Figura A14.2. Bloques","title":"A14-Detector de nivel agua"},{"location":"nivelagua/#practica-a141","text":"Vamos en primer lugar a leer los valores que da el sensor y mostrarlos por consola. Leer y mostrar los valores cuando el sensor est\u00e1 al aire y cuando se va introduciendo en el agua hasta llegar al m\u00e1ximo valor. El programa lo tenemos en la Figura A14.3. Figura A14.3. Soluci\u00f3n A14.1","title":"Pr\u00e1ctica A14.1"},{"location":"nivelagua/#practica-a142","text":"En esta pr\u00e1ctica vamos a realizar una alarma \u00f3ptico-ac\u00fastica que nos indique que tenemos una fuga de agua. Cuando el sensor de agua detecte un nivel del 10% se accionar\u00e1 la alarma de manera intermitente cada 5 segundos. El programa lo tenemos en la Figura A14.4. Figura A14.4. Soluci\u00f3n A14.2","title":"Pr\u00e1ctica A14.2"},{"location":"oled/","text":"A25-Pantalla gr\u00e1fica OLED de 0.96\" y 128x64 pixeles \u00b6 OLED es la abreviatura de (Organic Light-Emitting Diode) o diodo emisor de luz org\u00e1nico. Se dice org\u00e1nico debido a una pel\u00edcula de carbono que se encuentra en el interior del panel, detr\u00e1s del cristal protector. Cuando se colocan varias pel\u00edculas org\u00e1nicas entre dos conductores se puede hacer que cada pixel se ilumine de forma individual, haciendo muy eficiente este tipo de pantallas. Es decir, una pantalla OLED emite luz brillante propia al pasar corriente el\u00e9ctrica. La OLED Easy Plug es de tipo I2C. Su aspecto lo vemos en la Figura A25.1. Figura A25.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Visualizaci\u00f3n\" y tiene su propio men\u00fa de bloques (Figura A25.2). Figura A25.2. Bloques Antes de realizar actividades con la pantalla OLED es necesario conocer las herramientas disponibles en ArduinoBlocks para el trabajo con gr\u00e1ficos. Para poder mostrar gr\u00e1ficos debemos generar un mapa de bits que indique que pixeles estar\u00e1n apagados y cuales encendidos. ArduinoBlocks dispone de una herramienta visual (OLED - Bitmap Data) que nos permite generar f\u00e1cilmente el c\u00f3digo de los bitmaps y de un bloque que nos permite mostrarlos. El bloque para mostrar un bitmap es el de la figura A25.3. Figura A25.3. Bloque mostrar un bitmap A la herramienta OLED - Bitmap Data podemos acceder por cualquiera de los m\u00e9todos que vemos en la Figura A25.4 Figura A25.4. Acceso a OLED - Bitmap Data En la imagen de la Figura A25.5 vemos la pantalla OLED - Bitmap Data y la explicaci\u00f3n de sus partes. Figura A25.5. Pantalla OLED - Bitmap Data En la Figura A25.6 tenemos el bloque de mostrar bitmap con los datos del logo de ArduinoBlocks copiados en el mismo. Figura A25.6. Bloque mostrar bitmap con datos Pr\u00e1ctica A25.1 \u00b6 Vamos a mostrar en una pantalla OLED un logotipo. Mostrar en una OLED el logotipo de ArduinoBlocks. El programa y el resultado en una OLED real lo tenemos en la Figura A25.7. Figura A25.7. Soluci\u00f3n A25.1 Pr\u00e1ctica A25.2 \u00b6 Vamos a mostrar en una pantalla OLED un logotipo y un texto. *Mostrar en la pantalla OLED el mismo logotipo que en la pr\u00e1ctica A25.1 situando en la parte superior el texto \u201cManual EASY PLUG con\u201d en tama\u00f1o \u2018Small\u2019 y en la parte inferior el texto \u201cV1.1\u201d. El programa y el resultado en una OLED real lo tenemos en la Figura A25.8. Figura A25.8. Soluci\u00f3n A25.2","title":"A25-Pantalla gr\u00e1fica OLED"},{"location":"oled/#a25-pantalla-grafica-oled-de-096-y-128x64-pixeles","text":"OLED es la abreviatura de (Organic Light-Emitting Diode) o diodo emisor de luz org\u00e1nico. Se dice org\u00e1nico debido a una pel\u00edcula de carbono que se encuentra en el interior del panel, detr\u00e1s del cristal protector. Cuando se colocan varias pel\u00edculas org\u00e1nicas entre dos conductores se puede hacer que cada pixel se ilumine de forma individual, haciendo muy eficiente este tipo de pantallas. Es decir, una pantalla OLED emite luz brillante propia al pasar corriente el\u00e9ctrica. La OLED Easy Plug es de tipo I2C. Su aspecto lo vemos en la Figura A25.1. Figura A25.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Visualizaci\u00f3n\" y tiene su propio men\u00fa de bloques (Figura A25.2). Figura A25.2. Bloques Antes de realizar actividades con la pantalla OLED es necesario conocer las herramientas disponibles en ArduinoBlocks para el trabajo con gr\u00e1ficos. Para poder mostrar gr\u00e1ficos debemos generar un mapa de bits que indique que pixeles estar\u00e1n apagados y cuales encendidos. ArduinoBlocks dispone de una herramienta visual (OLED - Bitmap Data) que nos permite generar f\u00e1cilmente el c\u00f3digo de los bitmaps y de un bloque que nos permite mostrarlos. El bloque para mostrar un bitmap es el de la figura A25.3. Figura A25.3. Bloque mostrar un bitmap A la herramienta OLED - Bitmap Data podemos acceder por cualquiera de los m\u00e9todos que vemos en la Figura A25.4 Figura A25.4. Acceso a OLED - Bitmap Data En la imagen de la Figura A25.5 vemos la pantalla OLED - Bitmap Data y la explicaci\u00f3n de sus partes. Figura A25.5. Pantalla OLED - Bitmap Data En la Figura A25.6 tenemos el bloque de mostrar bitmap con los datos del logo de ArduinoBlocks copiados en el mismo. Figura A25.6. Bloque mostrar bitmap con datos","title":"A25-Pantalla gr\u00e1fica OLED de 0.96\" y 128x64 pixeles"},{"location":"oled/#practica-a251","text":"Vamos a mostrar en una pantalla OLED un logotipo. Mostrar en una OLED el logotipo de ArduinoBlocks. El programa y el resultado en una OLED real lo tenemos en la Figura A25.7. Figura A25.7. Soluci\u00f3n A25.1","title":"Pr\u00e1ctica A25.1"},{"location":"oled/#practica-a252","text":"Vamos a mostrar en una pantalla OLED un logotipo y un texto. *Mostrar en la pantalla OLED el mismo logotipo que en la pr\u00e1ctica A25.1 situando en la parte superior el texto \u201cManual EASY PLUG con\u201d en tama\u00f1o \u2018Small\u2019 y en la parte inferior el texto \u201cV1.1\u201d. El programa y el resultado en una OLED real lo tenemos en la Figura A25.8. Figura A25.8. Soluci\u00f3n A25.2","title":"Pr\u00e1ctica A25.2"},{"location":"pir/","text":"A09- Sensor de presencia PIR \u00b6 En esta pr\u00e1ctica, el objetivo es conocer el sensor de movimiento, tambi\u00e9n llamado PIR. El sensor PIR es un sensor de movimiento, que tal y como dice su nombre puede detectar se\u00f1ales infrarrojas provenientes de una persona, animal u objeto en movimiento. El sensor tiene el aspecto de la Figura A09.1 y en el se basan las alarmas que detectan movimiento. Figura A09.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A09.2). Figura A09.2. Bloques Pr\u00e1ctica A09.1 \u00b6 En esta pr\u00e1ctica utilizaremos el sensor PIR y un LED. Si detecta movimiento que se encienda el LED sino que se apague. En la Figura A09.3 tenemos el programa. Figura A09.3. Soluci\u00f3n A09.1 Pr\u00e1ctica A09.2 \u00b6 En esta pr\u00e1ctica reproduciremos una alarma. As\u00ed pues, utilizaremos el sensor PIR, y el zumbador pasivo. Si detecta movimiento que el zumbador emita un sonido similar a una alarma. Para ello, deber\u00e1 emitir los dos tipos de sonido que se observan durante 500 milisegundos cada uno, repitiendo ciertas veces. En la Figura A09.4 tenemos el programa. Figura A09.4. Soluci\u00f3n A09.2","title":"A09-Sensor PIR"},{"location":"pir/#a09-sensor-de-presencia-pir","text":"En esta pr\u00e1ctica, el objetivo es conocer el sensor de movimiento, tambi\u00e9n llamado PIR. El sensor PIR es un sensor de movimiento, que tal y como dice su nombre puede detectar se\u00f1ales infrarrojas provenientes de una persona, animal u objeto en movimiento. El sensor tiene el aspecto de la Figura A09.1 y en el se basan las alarmas que detectan movimiento. Figura A09.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A09.2). Figura A09.2. Bloques","title":"A09- Sensor de presencia PIR"},{"location":"pir/#practica-a091","text":"En esta pr\u00e1ctica utilizaremos el sensor PIR y un LED. Si detecta movimiento que se encienda el LED sino que se apague. En la Figura A09.3 tenemos el programa. Figura A09.3. Soluci\u00f3n A09.1","title":"Pr\u00e1ctica A09.1"},{"location":"pir/#practica-a092","text":"En esta pr\u00e1ctica reproduciremos una alarma. As\u00ed pues, utilizaremos el sensor PIR, y el zumbador pasivo. Si detecta movimiento que el zumbador emita un sonido similar a una alarma. Para ello, deber\u00e1 emitir los dos tipos de sonido que se observan durante 500 milisegundos cada uno, repitiendo ciertas veces. En la Figura A09.4 tenemos el programa. Figura A09.4. Soluci\u00f3n A09.2","title":"Pr\u00e1ctica A09.2"},{"location":"potenciometro/","text":"A10-El potenciometro \u00b6 En esta pr\u00e1ctica el objetivo es conocer el potenci\u00f3metro. El potenci\u00f3metro es un sensor rotativo en un \u00e1ngulo de 270\u00ba y es anal\u00f3gico. Su voltaje se puede subdividir en 1024 valores que tambi\u00e9n se pueden expresar en tanto por ciento. En la Figura A10.1 vemos su aspecto. Figura A10.1. Aspecto En el apartado de bloques de programaci\u00f3n se encuentra en \u201cSensores\u201d (Figura A10.2). Figura A10.2. Bloques Pr\u00e1ctica A10.1 \u00b6 En esta pr\u00e1ctica conoceremos c\u00f3mo funciona el potenci\u00f3metro. Los valores que se recogen pueden calcularse en porcentaje o en numeraci\u00f3n desde 0 hasta 1023 (combinaci\u00f3n binaria). En esta pr\u00e1ctica observaremos los par\u00e1metros y el movimiento del potenci\u00f3metro a trav\u00e9s de la consola. Por tanto, crearemos una variable que se llame \"potenci\u00f3metro\" y la asociaremos al sensor potenci\u00f3metro. Que la consola muestre cada segundo cu\u00e1l es el valor del potenci\u00f3metro. En la Figura A10.3 vemos el programa. Figura A10.3. Soluci\u00f3n A10.1 En la Figura A10.4 vemos los resultados que se obtienen en la consola. Figura A10.4. Consola A10.1 Pr\u00e1ctica A10.2 \u00b6 Ahora que conocemos c\u00f3mo averiguar el valor que entrega el potenci\u00f3metro lo programaremos combinando con un zumbador: Si el potenci\u00f3metro est\u00e1 entre 0 y 49% emitir\u00e1 un sonido, en cambio, si est\u00e1 entre 50% y 100% emitir\u00e1 otro sonido distinto. Por tanto, ahora haremos uso de la funci\u00f3n l\u00f3gica \"y\" o \u201cAND\u201d y la combinaremos con el de signos de mayor y menor. Es decir, dos bloques que vemos en la Figura A10.5. Figura A10.5. Bloques AND y mayor o igual Vamos a programar el intervalo de 0 a 49% mediante una funci\u00f3n AND y preguntando si potenci\u00f3metro es mayor o igual que 0 \u201cY\u201d menor o igual que 49. Para el otro intervalo preguntamos si es mayor o igual que 50 \u201cY\u201d menor o igual que 100. En este programa (Figura A10.6) es interesante visualizar lo que ocurre por la consola, pues as\u00ed podemos observar el cambio de porcentaje. Figura A10.6. Soluci\u00f3n A10.2 Pr\u00e1ctica A10.3 \u00b6 En esta tercera pr\u00e1ctica utilizaremos el potenci\u00f3metro para regular la intensidad luminosa de un LED. Recordemos que en la pr\u00e1ctica A02, estuvimos trabajando el PWM. En aquellas pr\u00e1cticas descubrimos que se med\u00eda su rango, entre los valores 0 y 255, es decir, un total de 256 valores. A la vez, sabemos que el potenci\u00f3metro puede darnos el rango de valores de 0 a 100% o tambi\u00e9n de 0 a 1023. Escogeremos esta \u00faltima condici\u00f3n y crearemos una variable de nombre potenci\u00f3metro. Pero esta vez dividiremos los valores que recoja entre 4, ya que si dividimos 1023 entre 4, nos sale 255. De esta forma podemos ver la similitud: 255 (m\u00e1xima intensidad del LED) y 1023 (m\u00e1ximo valor del potenci\u00f3metro). Empezamos creando la variable, para ello debemos ir al apartado de \"Matem\u00e1ticas\" y seleccionar el bloque de operadores. \u00c9ste bloque tiene un desplegable (Figura A10.7) y debemos escoger la divisi\u00f3n para nuestro caso. Figura A10.7. Operadores matem\u00e1ticos La variable potencimetro debe quedarnos como vemos en la Figura A10.8. Figura A10.8. Creaci\u00f3n de la variable Podemos comprobar como cambia esta nueva variable cuando movemos el potenci\u00f3metro, enviando valores a la consola, tal y como observar en la Figura A10.9. Figura A10.9. Visualizaci\u00f3n en consola del cambio en el potenci\u00f3metro Que a medida que vamos \"girando\" el potenci\u00f3metro, la intensidad del LED vaya subiendo. Para hacer este programa vamos a utilizar el bloque \u201cLed intensidad (PWM)\u201d al que asignaremos el valor de la variable potenci\u00f3metro. El programa lo vemos en la Figura A10.10. Figura A10.3. Soluci\u00f3n A10.10","title":"A10-El potenciometro"},{"location":"potenciometro/#a10-el-potenciometro","text":"En esta pr\u00e1ctica el objetivo es conocer el potenci\u00f3metro. El potenci\u00f3metro es un sensor rotativo en un \u00e1ngulo de 270\u00ba y es anal\u00f3gico. Su voltaje se puede subdividir en 1024 valores que tambi\u00e9n se pueden expresar en tanto por ciento. En la Figura A10.1 vemos su aspecto. Figura A10.1. Aspecto En el apartado de bloques de programaci\u00f3n se encuentra en \u201cSensores\u201d (Figura A10.2). Figura A10.2. Bloques","title":"A10-El potenciometro"},{"location":"potenciometro/#practica-a101","text":"En esta pr\u00e1ctica conoceremos c\u00f3mo funciona el potenci\u00f3metro. Los valores que se recogen pueden calcularse en porcentaje o en numeraci\u00f3n desde 0 hasta 1023 (combinaci\u00f3n binaria). En esta pr\u00e1ctica observaremos los par\u00e1metros y el movimiento del potenci\u00f3metro a trav\u00e9s de la consola. Por tanto, crearemos una variable que se llame \"potenci\u00f3metro\" y la asociaremos al sensor potenci\u00f3metro. Que la consola muestre cada segundo cu\u00e1l es el valor del potenci\u00f3metro. En la Figura A10.3 vemos el programa. Figura A10.3. Soluci\u00f3n A10.1 En la Figura A10.4 vemos los resultados que se obtienen en la consola. Figura A10.4. Consola A10.1","title":"Pr\u00e1ctica A10.1"},{"location":"potenciometro/#practica-a102","text":"Ahora que conocemos c\u00f3mo averiguar el valor que entrega el potenci\u00f3metro lo programaremos combinando con un zumbador: Si el potenci\u00f3metro est\u00e1 entre 0 y 49% emitir\u00e1 un sonido, en cambio, si est\u00e1 entre 50% y 100% emitir\u00e1 otro sonido distinto. Por tanto, ahora haremos uso de la funci\u00f3n l\u00f3gica \"y\" o \u201cAND\u201d y la combinaremos con el de signos de mayor y menor. Es decir, dos bloques que vemos en la Figura A10.5. Figura A10.5. Bloques AND y mayor o igual Vamos a programar el intervalo de 0 a 49% mediante una funci\u00f3n AND y preguntando si potenci\u00f3metro es mayor o igual que 0 \u201cY\u201d menor o igual que 49. Para el otro intervalo preguntamos si es mayor o igual que 50 \u201cY\u201d menor o igual que 100. En este programa (Figura A10.6) es interesante visualizar lo que ocurre por la consola, pues as\u00ed podemos observar el cambio de porcentaje. Figura A10.6. Soluci\u00f3n A10.2","title":"Pr\u00e1ctica A10.2"},{"location":"potenciometro/#practica-a103","text":"En esta tercera pr\u00e1ctica utilizaremos el potenci\u00f3metro para regular la intensidad luminosa de un LED. Recordemos que en la pr\u00e1ctica A02, estuvimos trabajando el PWM. En aquellas pr\u00e1cticas descubrimos que se med\u00eda su rango, entre los valores 0 y 255, es decir, un total de 256 valores. A la vez, sabemos que el potenci\u00f3metro puede darnos el rango de valores de 0 a 100% o tambi\u00e9n de 0 a 1023. Escogeremos esta \u00faltima condici\u00f3n y crearemos una variable de nombre potenci\u00f3metro. Pero esta vez dividiremos los valores que recoja entre 4, ya que si dividimos 1023 entre 4, nos sale 255. De esta forma podemos ver la similitud: 255 (m\u00e1xima intensidad del LED) y 1023 (m\u00e1ximo valor del potenci\u00f3metro). Empezamos creando la variable, para ello debemos ir al apartado de \"Matem\u00e1ticas\" y seleccionar el bloque de operadores. \u00c9ste bloque tiene un desplegable (Figura A10.7) y debemos escoger la divisi\u00f3n para nuestro caso. Figura A10.7. Operadores matem\u00e1ticos La variable potencimetro debe quedarnos como vemos en la Figura A10.8. Figura A10.8. Creaci\u00f3n de la variable Podemos comprobar como cambia esta nueva variable cuando movemos el potenci\u00f3metro, enviando valores a la consola, tal y como observar en la Figura A10.9. Figura A10.9. Visualizaci\u00f3n en consola del cambio en el potenci\u00f3metro Que a medida que vamos \"girando\" el potenci\u00f3metro, la intensidad del LED vaya subiendo. Para hacer este programa vamos a utilizar el bloque \u201cLed intensidad (PWM)\u201d al que asignaremos el valor de la variable potenci\u00f3metro. El programa lo vemos en la Figura A10.10. Figura A10.3. Soluci\u00f3n A10.10","title":"Pr\u00e1ctica A10.3"},{"location":"rec_emi_IR/","text":"A32-M\u00f3dulos receptor y emisor de infrarrojos IR \u00b6 Receptor IR \u00b6 El receptor de infrarrojos es un m\u00f3dulo con funciones de recepci\u00f3n, amplificaci\u00f3n y demodulaci\u00f3n para que entregue una se\u00f1al digital demodulada en frecuencia de 38KHz. Normalmente se utiliza junto con el m\u00f3dulo transmisor IR o alg\u00fan mando a distancia universal o un mando a distancia como el del enlace . Su aspecto lo vemos en la Figura A32.1. Figura A32.1. Aspecto receptor IR En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A32.2). Figura A32.2. Bloque receptor IR Emisor IR \u00b6 Un transmisor de infrarrojos es simplemente un diodo LED que genera luz infrarroja. Por ejemplo, en un control remoto infrarrojo al presionar un bot\u00f3n se env\u00eda una se\u00f1al al LED IR, que convierte la se\u00f1al en un haz de luz infrarroja. El dispositivo receptor detecta la luz con un fotodiodo IR y la convierte en una se\u00f1al el\u00e9ctrica a trav\u00e9s de un circuito integrado, controlando as\u00ed sus acciones. Los transmisores infrarrojos se utilizan ampliamente como medio de comunicaci\u00f3n inal\u00e1mbrica mediante controles remotos para televisores y otros dispositivos electr\u00f3nicos. Este m\u00f3dulo transmisor IR se empareja con el m\u00f3dulo receptor IR y sus principales caracter\u00edsticas son: Frecuencia central infrarroja: 850nm a 940nm \u00c1ngulo de emisi\u00f3n infrarroja: 20 grados Distancia de emisi\u00f3n infrarroja: 1.3m (5V 38Khz) Su aspecto lo vemos en la Figura A32.3. Figura A32.3. Aspecto emisor IR En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\" (Figura A32.4). Figura A32.4. Bloque emisor IR El bloque permite seleccionar el protocolo al que pertenece el c\u00f3digo a enviar que pongamos en el campo correspondiente y solamente permite conectar el m\u00f3dulo al pin D3. Para obtener la informaci\u00f3n de un mando IR cualquiera y decodificar el protocolo, n\u00famero de bits y c\u00f3digo de cada tecla podemos seguir este tutorial de Adafruit sobre la utilizaci\u00f3n de su librer\u00eda de IR para el IDE de Arduino. Pr\u00e1ctica A32.1 \u00b6 Vamos a enviar un c\u00f3digo desde el m\u00f3dulo emisor, lo visualizamos en la LCD, lo recibimos en el receptor y lo visualizamos tambi\u00e9n en la LCD. Enviar el c\u00f3digo Sony 0xA90 (2704 en decimal) desde el m\u00f3dulo emisor y comprobar si el m\u00f3dulo receptor lo recibe mostrando los resultados en una pantalla LCD. El programa lo tenemos en la Figura A32.5. Figura A32.5. Soluci\u00f3n A32.1","title":"A32-Receptor y emisor de infrarrojos IR"},{"location":"rec_emi_IR/#a32-modulos-receptor-y-emisor-de-infrarrojos-ir","text":"","title":"A32-M\u00f3dulos receptor y emisor de infrarrojos IR"},{"location":"rec_emi_IR/#receptor-ir","text":"El receptor de infrarrojos es un m\u00f3dulo con funciones de recepci\u00f3n, amplificaci\u00f3n y demodulaci\u00f3n para que entregue una se\u00f1al digital demodulada en frecuencia de 38KHz. Normalmente se utiliza junto con el m\u00f3dulo transmisor IR o alg\u00fan mando a distancia universal o un mando a distancia como el del enlace . Su aspecto lo vemos en la Figura A32.1. Figura A32.1. Aspecto receptor IR En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A32.2). Figura A32.2. Bloque receptor IR","title":"Receptor IR"},{"location":"rec_emi_IR/#emisor-ir","text":"Un transmisor de infrarrojos es simplemente un diodo LED que genera luz infrarroja. Por ejemplo, en un control remoto infrarrojo al presionar un bot\u00f3n se env\u00eda una se\u00f1al al LED IR, que convierte la se\u00f1al en un haz de luz infrarroja. El dispositivo receptor detecta la luz con un fotodiodo IR y la convierte en una se\u00f1al el\u00e9ctrica a trav\u00e9s de un circuito integrado, controlando as\u00ed sus acciones. Los transmisores infrarrojos se utilizan ampliamente como medio de comunicaci\u00f3n inal\u00e1mbrica mediante controles remotos para televisores y otros dispositivos electr\u00f3nicos. Este m\u00f3dulo transmisor IR se empareja con el m\u00f3dulo receptor IR y sus principales caracter\u00edsticas son: Frecuencia central infrarroja: 850nm a 940nm \u00c1ngulo de emisi\u00f3n infrarroja: 20 grados Distancia de emisi\u00f3n infrarroja: 1.3m (5V 38Khz) Su aspecto lo vemos en la Figura A32.3. Figura A32.3. Aspecto emisor IR En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\" (Figura A32.4). Figura A32.4. Bloque emisor IR El bloque permite seleccionar el protocolo al que pertenece el c\u00f3digo a enviar que pongamos en el campo correspondiente y solamente permite conectar el m\u00f3dulo al pin D3. Para obtener la informaci\u00f3n de un mando IR cualquiera y decodificar el protocolo, n\u00famero de bits y c\u00f3digo de cada tecla podemos seguir este tutorial de Adafruit sobre la utilizaci\u00f3n de su librer\u00eda de IR para el IDE de Arduino.","title":"Emisor IR"},{"location":"rec_emi_IR/#practica-a321","text":"Vamos a enviar un c\u00f3digo desde el m\u00f3dulo emisor, lo visualizamos en la LCD, lo recibimos en el receptor y lo visualizamos tambi\u00e9n en la LCD. Enviar el c\u00f3digo Sony 0xA90 (2704 en decimal) desde el m\u00f3dulo emisor y comprobar si el m\u00f3dulo receptor lo recibe mostrando los resultados en una pantalla LCD. El programa lo tenemos en la Figura A32.5. Figura A32.5. Soluci\u00f3n A32.1","title":"Pr\u00e1ctica A32.1"},{"location":"reed/","text":"A34-M\u00f3dulo rel\u00e9 Reed \u00b6 Un interruptor de leng\u00fceta o reed switch o rel\u00e9 reed es un interruptor el\u00e9ctrico activado por un campo magn\u00e9tico. Cuando los contactos est\u00e1n normalmente abiertos se cierran en la presencia de un campo magn\u00e9tico; cuando est\u00e1n normalmente cerrados se abren en presencia de un campo magn\u00e9tico. Este m\u00f3dulo incluye un rel\u00e9 reed que cierra sus contactos cuando se expone a un campo magn\u00e9tico y est\u00e1n abiertos si no hay campo magn\u00e9tico presente. es un peque\u00f1o dispositivo llamado interruptor de l\u00e1minas en el m\u00f3dulo. Esto lo hace \u00fatil para montarlo por ejemplo en una puerta con prop\u00f3sito de activar una alarma o como interruptor. Sus principales caracter\u00edsticas son: Voltaje de funcionamiento: 3,3 V a 5 V DC Corriente de trabajo: \u226520mA Temperatura de trabajo: -10 \u2103 a \uff0b50 \u2103 Distancia de detecci\u00f3n: \u226410 mm Su aspecto lo vemos en la Figura A34.1. Figura A34.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A34.2). Figura A34.2. Bloques Pr\u00e1ctica A34.1 \u00b6 Vamos a montar un sistema que cuando acerquemos un im\u00e1n se encienda un diodo LED. Implementar un programa que haga funcionar al rel\u00e9 reed como detector magn\u00e9tico en una supuesta puerta de un armario. Cuando la puerta est\u00e1 cerrada se detecta el campo magn\u00e9tico y el diodo LED est\u00e1 apagado y cuando se abre este debe apagarse. El programa lo tenemos en la Figura A34.3. Figura A34.3. Soluci\u00f3n A34.1","title":"A34-M\u00f3dulo rel\u00e9 Reed"},{"location":"reed/#a34-modulo-rele-reed","text":"Un interruptor de leng\u00fceta o reed switch o rel\u00e9 reed es un interruptor el\u00e9ctrico activado por un campo magn\u00e9tico. Cuando los contactos est\u00e1n normalmente abiertos se cierran en la presencia de un campo magn\u00e9tico; cuando est\u00e1n normalmente cerrados se abren en presencia de un campo magn\u00e9tico. Este m\u00f3dulo incluye un rel\u00e9 reed que cierra sus contactos cuando se expone a un campo magn\u00e9tico y est\u00e1n abiertos si no hay campo magn\u00e9tico presente. es un peque\u00f1o dispositivo llamado interruptor de l\u00e1minas en el m\u00f3dulo. Esto lo hace \u00fatil para montarlo por ejemplo en una puerta con prop\u00f3sito de activar una alarma o como interruptor. Sus principales caracter\u00edsticas son: Voltaje de funcionamiento: 3,3 V a 5 V DC Corriente de trabajo: \u226520mA Temperatura de trabajo: -10 \u2103 a \uff0b50 \u2103 Distancia de detecci\u00f3n: \u226410 mm Su aspecto lo vemos en la Figura A34.1. Figura A34.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A34.2). Figura A34.2. Bloques","title":"A34-M\u00f3dulo rel\u00e9 Reed"},{"location":"reed/#practica-a341","text":"Vamos a montar un sistema que cuando acerquemos un im\u00e1n se encienda un diodo LED. Implementar un programa que haga funcionar al rel\u00e9 reed como detector magn\u00e9tico en una supuesta puerta de un armario. Cuando la puerta est\u00e1 cerrada se detecta el campo magn\u00e9tico y el diodo LED est\u00e1 apagado y cuando se abre este debe apagarse. El programa lo tenemos en la Figura A34.3. Figura A34.3. Soluci\u00f3n A34.1","title":"Pr\u00e1ctica A34.1"},{"location":"rele/","text":"A26-M\u00f3dulo rel\u00e9 \u00b6 Un rel\u00e9 es b\u00e1sicamente un interruptor mec\u00e1nico controlado el\u00e9ctricamente de forma que a trav\u00e9s de una peque\u00f1a tensi\u00f3n y corriente se puede controlar la apertura y cierre de sus contactos mec\u00e1nicos donde se puede trabajar con tensiones y corrientes elevadas. El m\u00f3dulo incluye un LED que nos indica si el rel\u00e9 est\u00e1 accionado cuando se enciende. El modelo de rel\u00e9 que lleva este m\u00f3dulo es el SRD-05VDC-SL-C que presenta las siguientes caracter\u00edsticas: En AC (corriente alterna): 250Vac / 10A En DC (corriente continua): 30Vdc / 10A o bien 250Vdc / 1A Tensi\u00f3n de la bobina: 5V, compatible con se\u00f1ales TTL para su excitaci\u00f3n Contactos: 3 pines, 1 Com\u00fan + 1 contacto NA (normalmente abierto) + 1 contacto NC (normalmente cerrado) Esquem\u00e1ticamente un rel\u00e9 de este tipo se puede parecer a la imagen de la Figura A26.1. Figura A26.1. Aspecto esquem\u00e1tico de un rel\u00e9 Fuente: wikipedia En el enlace podemos ver una animaci\u00f3n del funcionamiento de un rel\u00e9 Su aspecto lo vemos en la Figura A26.2. Figura A26.2. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\" (Figura A26.3). Figura A26.3. Bloques Pr\u00e1ctica A26.1 \u00b6 Vamos a controlar el accionamiento de un rel\u00e9 desde nuestro ordenador a trav\u00e9s de la consola serie. Conectar un m\u00f3dulo rel\u00e9 y vamos a hacer que funcione a trav\u00e9s de los siguientes comandos que enviaremos desde la consola: 1 \u2013> ON, 2\u2192 OFF y 3 \u2192 Conmutar ON/OFF a 500 ms. El programa lo tenemos en la Figura A26.4. Figura A26.4. Soluci\u00f3n A26.1 El aspecto de la consola lista para enviar el comando de encendido lo vemos en la Figura A26.5. Figura A26.5. Consola de la actividad A26.1","title":"A26-M\u00f3dulo rel\u00e9"},{"location":"rele/#a26-modulo-rele","text":"Un rel\u00e9 es b\u00e1sicamente un interruptor mec\u00e1nico controlado el\u00e9ctricamente de forma que a trav\u00e9s de una peque\u00f1a tensi\u00f3n y corriente se puede controlar la apertura y cierre de sus contactos mec\u00e1nicos donde se puede trabajar con tensiones y corrientes elevadas. El m\u00f3dulo incluye un LED que nos indica si el rel\u00e9 est\u00e1 accionado cuando se enciende. El modelo de rel\u00e9 que lleva este m\u00f3dulo es el SRD-05VDC-SL-C que presenta las siguientes caracter\u00edsticas: En AC (corriente alterna): 250Vac / 10A En DC (corriente continua): 30Vdc / 10A o bien 250Vdc / 1A Tensi\u00f3n de la bobina: 5V, compatible con se\u00f1ales TTL para su excitaci\u00f3n Contactos: 3 pines, 1 Com\u00fan + 1 contacto NA (normalmente abierto) + 1 contacto NC (normalmente cerrado) Esquem\u00e1ticamente un rel\u00e9 de este tipo se puede parecer a la imagen de la Figura A26.1. Figura A26.1. Aspecto esquem\u00e1tico de un rel\u00e9 Fuente: wikipedia En el enlace podemos ver una animaci\u00f3n del funcionamiento de un rel\u00e9 Su aspecto lo vemos en la Figura A26.2. Figura A26.2. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\" (Figura A26.3). Figura A26.3. Bloques","title":"A26-M\u00f3dulo rel\u00e9"},{"location":"rele/#practica-a261","text":"Vamos a controlar el accionamiento de un rel\u00e9 desde nuestro ordenador a trav\u00e9s de la consola serie. Conectar un m\u00f3dulo rel\u00e9 y vamos a hacer que funcione a trav\u00e9s de los siguientes comandos que enviaremos desde la consola: 1 \u2013> ON, 2\u2192 OFF y 3 \u2192 Conmutar ON/OFF a 500 ms. El programa lo tenemos en la Figura A26.4. Figura A26.4. Soluci\u00f3n A26.1 El aspecto de la consola lista para enviar el comando de encendido lo vemos en la Figura A26.5. Figura A26.5. Consola de la actividad A26.1","title":"Pr\u00e1ctica A26.1"},{"location":"rtc/","text":"A29-M\u00f3dulo RTC DS3231 \u00b6 El circuito integrado DS3231 en el que se basa el m\u00f3dulo es un reloj I2C en tiempo real (RTC de Real Time Clock) muy preciso con un oscilador de cristal compensado con la temperatura que nos devuelve la hora y la fecha. El dispositivo incorpora una bater\u00eda encargada de mantener la hora y fechas ajustadas cuando se interrumpe la alimentaci\u00f3n principal al mismo. Su aspecto lo vemos en la Figura A29.1. Figura A29.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Perif\u00e9ricos\" y tiene sus propios bloques (Figura A29.2). Figura A29.2. Bloques Pr\u00e1ctica A29.1 \u00b6 Ajuste de fecha y hora del m\u00f3dulo RTC DS3231 Ajustar la fecha y hora actuales o las deseadas en el RTC y mostrar sus valores le\u00eddos del dispositivo. En esta ocasi\u00f3n vamos a utilizar dos dispositivos I2C por lo que se hace necesario el uso del Hub I2C para conectar ambos a la \u00fanica entrada de que dispone la placa. L\u00f3gicamente el ajuste solamente lo debemos realizar una vez y a partir de ah\u00ed no poner el bloque de configuraci\u00f3n en nuestro programa y que sea la bater\u00eda la encargada de mantener la fecha y la hora. El valor que lee el bloque para la fecha y la hora por defecto es el del ordenador. El programa lo tenemos en la Figura A29.3. Figura A29.3. Soluci\u00f3n A29.1 El aspecto de la LCD justo despu\u00e9s de subir el programa y transcurridos unos minutos sin alimentar tras los cuales volvemos a conectar el sistema lo vemos en la Figura A29.4. Figura A29.4. Consola de la actividad A29.1","title":"A29-M\u00f3dulo RTC DS3231"},{"location":"rtc/#a29-modulo-rtc-ds3231","text":"El circuito integrado DS3231 en el que se basa el m\u00f3dulo es un reloj I2C en tiempo real (RTC de Real Time Clock) muy preciso con un oscilador de cristal compensado con la temperatura que nos devuelve la hora y la fecha. El dispositivo incorpora una bater\u00eda encargada de mantener la hora y fechas ajustadas cuando se interrumpe la alimentaci\u00f3n principal al mismo. Su aspecto lo vemos en la Figura A29.1. Figura A29.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Perif\u00e9ricos\" y tiene sus propios bloques (Figura A29.2). Figura A29.2. Bloques","title":"A29-M\u00f3dulo RTC DS3231"},{"location":"rtc/#practica-a291","text":"Ajuste de fecha y hora del m\u00f3dulo RTC DS3231 Ajustar la fecha y hora actuales o las deseadas en el RTC y mostrar sus valores le\u00eddos del dispositivo. En esta ocasi\u00f3n vamos a utilizar dos dispositivos I2C por lo que se hace necesario el uso del Hub I2C para conectar ambos a la \u00fanica entrada de que dispone la placa. L\u00f3gicamente el ajuste solamente lo debemos realizar una vez y a partir de ah\u00ed no poner el bloque de configuraci\u00f3n en nuestro programa y que sea la bater\u00eda la encargada de mantener la fecha y la hora. El valor que lee el bloque para la fecha y la hora por defecto es el del ordenador. El programa lo tenemos en la Figura A29.3. Figura A29.3. Soluci\u00f3n A29.1 El aspecto de la LCD justo despu\u00e9s de subir el programa y transcurridos unos minutos sin alimentar tras los cuales volvemos a conectar el sistema lo vemos en la Figura A29.4. Figura A29.4. Consola de la actividad A29.1","title":"Pr\u00e1ctica A29.1"},{"location":"servo/","text":"A23-Servomotor \u00b6 Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesita alimentaci\u00f3n ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control. El interior de un servo lo vamos esquematizado en la Figura A23.1. Figura A23.1. Esquema de un servomotor Su aspecto lo vemos en la Figura A23.2. Figura A23.2. Aspecto Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados. El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores). El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz). Para poder conectar un servomotor a la placa Easy Plug debemos utilizar el adaptador que vemos en la Figura A23.3. Figura A23.3. Adaptador servo de modular a Easy Plug Hay que tener mucho cuidado de posicionar el conector del servo en los tres pines macho del adaptador para hacerlo en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irreversible. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\" (Figura A23.4). Figura A23.4. Bloques Para controlar el servomotor, indicamos los grados de rotaci\u00f3n (\u00c1ngulo de giro) que queremos y el tiempo de retardo, o tiempo que tarda en ir de una posici\u00f3n a otra. Pr\u00e1ctica A23.1 \u00b6 Vamos a posicionar el servo en su \u00e1ngulo de 0\u00ba u origen. Esta pr\u00e1ctica es siempre una buena idea cuando no sabemos cual es la posici\u00f3n 0\u00ba del servo. Programar, por primera vez el \u00e1ngulo a 0\u00ba para descubrir el punto de origen y a partir de aqu\u00ed montar alguna pala de las que vienen con el servo para poder visualizar la rotaci\u00f3n del eje. El programa lo tenemos en la Figura A23.5. Figura A23.5. Soluci\u00f3n A23.1 Pr\u00e1ctica A23.2 \u00b6 Una vez averiguada la posici\u00f3n inicial del servo vamos a hacer que este se mueva con la siguiente secuencia de \u00e1ngulos: 0, 45, 90, 135, 180, 150, 120, 90, 60, 30, 0. Hacer que el servo gire de 0 a 180 en incrementos de 45\u00ba con un retardo de 2 segundos y de 180 a cero con un decremento de 30\u00ba y un retardo de un segundo. El programa lo tenemos en la Figura A23.6. Figura A23.6. Soluci\u00f3n A23.2","title":"A23-Servomotor"},{"location":"servo/#a23-servomotor","text":"Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesita alimentaci\u00f3n ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control. El interior de un servo lo vamos esquematizado en la Figura A23.1. Figura A23.1. Esquema de un servomotor Su aspecto lo vemos en la Figura A23.2. Figura A23.2. Aspecto Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados. El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores). El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz). Para poder conectar un servomotor a la placa Easy Plug debemos utilizar el adaptador que vemos en la Figura A23.3. Figura A23.3. Adaptador servo de modular a Easy Plug Hay que tener mucho cuidado de posicionar el conector del servo en los tres pines macho del adaptador para hacerlo en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irreversible. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\" (Figura A23.4). Figura A23.4. Bloques Para controlar el servomotor, indicamos los grados de rotaci\u00f3n (\u00c1ngulo de giro) que queremos y el tiempo de retardo, o tiempo que tarda en ir de una posici\u00f3n a otra.","title":"A23-Servomotor"},{"location":"servo/#practica-a231","text":"Vamos a posicionar el servo en su \u00e1ngulo de 0\u00ba u origen. Esta pr\u00e1ctica es siempre una buena idea cuando no sabemos cual es la posici\u00f3n 0\u00ba del servo. Programar, por primera vez el \u00e1ngulo a 0\u00ba para descubrir el punto de origen y a partir de aqu\u00ed montar alguna pala de las que vienen con el servo para poder visualizar la rotaci\u00f3n del eje. El programa lo tenemos en la Figura A23.5. Figura A23.5. Soluci\u00f3n A23.1","title":"Pr\u00e1ctica A23.1"},{"location":"servo/#practica-a232","text":"Una vez averiguada la posici\u00f3n inicial del servo vamos a hacer que este se mueva con la siguiente secuencia de \u00e1ngulos: 0, 45, 90, 135, 180, 150, 120, 90, 60, 30, 0. Hacer que el servo gire de 0 a 180 en incrementos de 45\u00ba con un retardo de 2 segundos y de 180 a cero con un decremento de 30\u00ba y un retardo de un segundo. El programa lo tenemos en la Figura A23.6. Figura A23.6. Soluci\u00f3n A23.2","title":"Pr\u00e1ctica A23.2"},{"location":"slide/","text":"A31-Potenci\u00f3metro deslizante \u00b6 El potenci\u00f3metro deslizante o slide es una resistencia variable a la que podemos cambiar su valor deslizando un cursor por una resistencia a lo largo de toda su longitud. Muy caracter\u00edstico de mesas de mezclas de audio. En realidad se trata de un potenci\u00f3metro doble montados de forma que cuando uno aumenta su resistencia el otro la disminuya y viceversa. Su aspecto lo vemos en la Figura A31.1. Figura A31.1. Aspecto El color con el que viene marcado nos indica que es un sensor anal\u00f3gico pero en realidad funciona con dos pines anal\u00f3gicos y el \u00fanico conector de la placa que los tiene es el marcado en rojo y amarillo (D6 y D7) que son los \u00fanicos pines que deja conectar el bloque de ArduinoBlocks. En realidad se trata de una salida anal\u00f3gica dual que nos entrega una se\u00f1al anal\u00f3gica variable entre 0 y VCC, es decir valores entre 0 y 1023 (o 0 y 100%). La suma de los dos valores anal\u00f3gicos que da el potenci\u00f3metro es 1023. Hay posibilidad de soldar dos conectores de 3 pines de paso 2,54 mm en el m\u00f3dulo que permite su conexi\u00f3n con otros dispositivos. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A31.2). Figura A31.2. Bloques Pr\u00e1ctica A31.1 \u00b6 Vamos a medir las variaciones de las resistencias del potenci\u00f3metro. Mostrar en la consola el valor como lectura anal\u00f3gica de 0 a 1023 de cada una de las resistencia del potenci\u00f3metro deslizante. El programa lo tenemos en la Figura A31.3. Figura A31.3. Soluci\u00f3n A31.1 Pr\u00e1ctica A31.2 \u00b6 Controlar un servo 0-180\u00ba mediante el potenci\u00f3metro deslizante. Realizar el mapeo de una variable que mide las variaciones de resistencia de un potenci\u00f3metro deslizante de forma que haga girar a un servo entre 0 y 180\u00ba en funci\u00f3n del valor de la resistencia del mismo. El programa lo tenemos en la Figura A31.4. Figura A31.4. Soluci\u00f3n A31.2","title":"A31-Potenci\u00f3metro deslizante"},{"location":"slide/#a31-potenciometro-deslizante","text":"El potenci\u00f3metro deslizante o slide es una resistencia variable a la que podemos cambiar su valor deslizando un cursor por una resistencia a lo largo de toda su longitud. Muy caracter\u00edstico de mesas de mezclas de audio. En realidad se trata de un potenci\u00f3metro doble montados de forma que cuando uno aumenta su resistencia el otro la disminuya y viceversa. Su aspecto lo vemos en la Figura A31.1. Figura A31.1. Aspecto El color con el que viene marcado nos indica que es un sensor anal\u00f3gico pero en realidad funciona con dos pines anal\u00f3gicos y el \u00fanico conector de la placa que los tiene es el marcado en rojo y amarillo (D6 y D7) que son los \u00fanicos pines que deja conectar el bloque de ArduinoBlocks. En realidad se trata de una salida anal\u00f3gica dual que nos entrega una se\u00f1al anal\u00f3gica variable entre 0 y VCC, es decir valores entre 0 y 1023 (o 0 y 100%). La suma de los dos valores anal\u00f3gicos que da el potenci\u00f3metro es 1023. Hay posibilidad de soldar dos conectores de 3 pines de paso 2,54 mm en el m\u00f3dulo que permite su conexi\u00f3n con otros dispositivos. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A31.2). Figura A31.2. Bloques","title":"A31-Potenci\u00f3metro deslizante"},{"location":"slide/#practica-a311","text":"Vamos a medir las variaciones de las resistencias del potenci\u00f3metro. Mostrar en la consola el valor como lectura anal\u00f3gica de 0 a 1023 de cada una de las resistencia del potenci\u00f3metro deslizante. El programa lo tenemos en la Figura A31.3. Figura A31.3. Soluci\u00f3n A31.1","title":"Pr\u00e1ctica A31.1"},{"location":"slide/#practica-a312","text":"Controlar un servo 0-180\u00ba mediante el potenci\u00f3metro deslizante. Realizar el mapeo de una variable que mide las variaciones de resistencia de un potenci\u00f3metro deslizante de forma que haga girar a un servo entre 0 y 180\u00ba en funci\u00f3n del valor de la resistencia del mismo. El programa lo tenemos en la Figura A31.4. Figura A31.4. Soluci\u00f3n A31.2","title":"Pr\u00e1ctica A31.2"},{"location":"sonido/","text":"A13-Sensor anal\u00f3gico de sonido \u00b6 El sensor de sonido est\u00e1 dotado de un micr\u00f3fono capaz de detectar el volumen de ruido ambiental. Se puede usar para hacer circuitos tipo interruptor operado por voz. Se trata de un sensor de tipo anal\u00f3gico. La sensibilidad del sonido se puede ajustar mediante el potenci\u00f3metro. Su aspecto lo vemos en la Figura A13.1. Figura A13.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A13.2). Figura A13.2. Bloques Pr\u00e1ctica A13.1 \u00b6 Lo primero que vamos a hacer es leer la salida del sensor y comprobar como cambia su sensibilidad al mover el potenci\u00f3metro. Lectura del sensor de sonido y ajuste de la sensibilidad mostrando los datos por consola tanto en valor num\u00e9rico como en porcentaje. El programa lo tenemos en la Figura A13.3. Figura A13.3. Soluci\u00f3n A13.1 Pr\u00e1ctica A13.2 \u00b6 Usaremos el sensor de sonido como un interruptor. Cuando el nivel sonoro supere el 35% que se encienda un LED rojo. El programa lo tenemos en la Figura A13.4. Figura A13.4. Soluci\u00f3n A13.2","title":"A13-Sensor anal\u00f3gico de sonido"},{"location":"sonido/#a13-sensor-analogico-de-sonido","text":"El sensor de sonido est\u00e1 dotado de un micr\u00f3fono capaz de detectar el volumen de ruido ambiental. Se puede usar para hacer circuitos tipo interruptor operado por voz. Se trata de un sensor de tipo anal\u00f3gico. La sensibilidad del sonido se puede ajustar mediante el potenci\u00f3metro. Su aspecto lo vemos en la Figura A13.1. Figura A13.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A13.2). Figura A13.2. Bloques","title":"A13-Sensor anal\u00f3gico de sonido"},{"location":"sonido/#practica-a131","text":"Lo primero que vamos a hacer es leer la salida del sensor y comprobar como cambia su sensibilidad al mover el potenci\u00f3metro. Lectura del sensor de sonido y ajuste de la sensibilidad mostrando los datos por consola tanto en valor num\u00e9rico como en porcentaje. El programa lo tenemos en la Figura A13.3. Figura A13.3. Soluci\u00f3n A13.1","title":"Pr\u00e1ctica A13.1"},{"location":"sonido/#practica-a132","text":"Usaremos el sensor de sonido como un interruptor. Cuando el nivel sonoro supere el 35% que se encienda un LED rojo. El programa lo tenemos en la Figura A13.4. Figura A13.4. Soluci\u00f3n A13.2","title":"Pr\u00e1ctica A13.2"},{"location":"temt6000/","text":"A21-Sensor de luz ambiental TEMT6000 \u00b6 El sensor de luz ambiental TEMT6000 es un sensor anal\u00f3gico con mayor sensibilidad que la LDR. En teor\u00eda el TEMT6000 est\u00e1 adaptado seg\u00fan la sensibilidad del ojo humano. Es posible que con niveles de poca luz no sea muy sensible, y, al igual que el ojo humano, no reacciona bien a la luz infrarroja o ultravioleta. Su aspecto lo vemos en la Figura A21.1. Figura A21.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A21.2). Figura A21.2. Bloques Pr\u00e1ctica A21.1 \u00b6 Vamos a medir el nivel de luz ambiente de una habitaci\u00f3n. Mostrar en una LCD el nivel de luz ambiental de una habitaci\u00f3n expresado en %. El programa lo tenemos en la Figura A21.3. Figura A21.3. Soluci\u00f3n A21.1","title":"A21-Sensor de luz ambiental TEMT6000"},{"location":"temt6000/#a21-sensor-de-luz-ambiental-temt6000","text":"El sensor de luz ambiental TEMT6000 es un sensor anal\u00f3gico con mayor sensibilidad que la LDR. En teor\u00eda el TEMT6000 est\u00e1 adaptado seg\u00fan la sensibilidad del ojo humano. Es posible que con niveles de poca luz no sea muy sensible, y, al igual que el ojo humano, no reacciona bien a la luz infrarroja o ultravioleta. Su aspecto lo vemos en la Figura A21.1. Figura A21.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A21.2). Figura A21.2. Bloques","title":"A21-Sensor de luz ambiental TEMT6000"},{"location":"temt6000/#practica-a211","text":"Vamos a medir el nivel de luz ambiente de una habitaci\u00f3n. Mostrar en una LCD el nivel de luz ambiental de una habitaci\u00f3n expresado en %. El programa lo tenemos en la Figura A21.3. Figura A21.3. Soluci\u00f3n A21.1","title":"Pr\u00e1ctica A21.1"},{"location":"termistor/","text":"A12-Sensor anal\u00f3gico de temperatura, el termistor \u00b6 Un termistor es una resistencia cuyo valor depende la temperatura y es por tanto un sensor anal\u00f3gico que sirve para detectar temperatura. El sensor anal\u00f3gico de temperatura est\u00e1 basado en un termistor y nos va a servir por tanto para medir la temperatura. Su aspecto lo vemos en la Figura A12.1. Figura A12.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A12.2). Figura A12.2. Bloques Pr\u00e1ctica A12.1 \u00b6 Enviar a la consola serie la medida de temperatura cada tres segundos. El programa lo tenemos en la Figura A12.3. Figura A12.3. Soluci\u00f3n A12.1 Pr\u00e1ctica A12.2 \u00b6 Simular un termostato de forma que si la temperatura est\u00e1 por debajo de un valor de 18 \u00baC se encienda un LED que indica que se activa la calefacci\u00f3n y si est\u00e1 por encima de 20 \u00baC que se encienda un LED verde, se apague el rojo indicando que la estancia est\u00e1 a una temperatura superior a los 18 \u00baC. El programa lo tenemos en la Figura A12.4. Figura A12.4. Soluci\u00f3n A12.2","title":"A12-Sensor anal\u00f3gico de temperatura"},{"location":"termistor/#a12-sensor-analogico-de-temperatura-el-termistor","text":"Un termistor es una resistencia cuyo valor depende la temperatura y es por tanto un sensor anal\u00f3gico que sirve para detectar temperatura. El sensor anal\u00f3gico de temperatura est\u00e1 basado en un termistor y nos va a servir por tanto para medir la temperatura. Su aspecto lo vemos en la Figura A12.1. Figura A12.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A12.2). Figura A12.2. Bloques","title":"A12-Sensor anal\u00f3gico de temperatura, el termistor"},{"location":"termistor/#practica-a121","text":"Enviar a la consola serie la medida de temperatura cada tres segundos. El programa lo tenemos en la Figura A12.3. Figura A12.3. Soluci\u00f3n A12.1","title":"Pr\u00e1ctica A12.1"},{"location":"termistor/#practica-a122","text":"Simular un termostato de forma que si la temperatura est\u00e1 por debajo de un valor de 18 \u00baC se encienda un LED que indica que se activa la calefacci\u00f3n y si est\u00e1 por encima de 20 \u00baC que se encienda un LED verde, se apague el rojo indicando que la estancia est\u00e1 a una temperatura superior a los 18 \u00baC. El programa lo tenemos en la Figura A12.4. Figura A12.4. Soluci\u00f3n A12.2","title":"Pr\u00e1ctica A12.2"},{"location":"tilt/","text":"A18-Sensor de inclinaci\u00f3n (tilt) \u00b6 El interruptor de inclinaci\u00f3n es el equivalente a un bot\u00f3n y se utiliza como entrada digital. Dentro del interruptor de inclinaci\u00f3n hay una bolita met\u00e1lica que hace contacto con los pines cuando el sensor est\u00e1 en posici\u00f3n vertical. Inclinando el sensor la bolita no toca los contactos, por lo que deja el circuito abierto. La idea es que cuando el sensor est\u00e1 horizontal est\u00e1 abierto y cuando se inclina se cierra, lo que permite detectar una determinada orientaci\u00f3n. Su aspecto y principio de funcionamiento lo vemos en la Figura A18.1. Figura A18.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A18.2). Figura A18.2. Bloques Pr\u00e1ctica A18.1 \u00b6 Vamos a detectar la posici\u00f3n no vertical del sensor de orientaci\u00f3n. Encender un LED cuando el sensor de orientaci\u00f3n no est\u00e9 en posici\u00f3n vertical. El programa lo tenemos en la Figura A18.3. Figura A18.3. Soluci\u00f3n A18.1","title":"A18-Sensor de inclinaci\u00f3n (tilt)"},{"location":"tilt/#a18-sensor-de-inclinacion-tilt","text":"El interruptor de inclinaci\u00f3n es el equivalente a un bot\u00f3n y se utiliza como entrada digital. Dentro del interruptor de inclinaci\u00f3n hay una bolita met\u00e1lica que hace contacto con los pines cuando el sensor est\u00e1 en posici\u00f3n vertical. Inclinando el sensor la bolita no toca los contactos, por lo que deja el circuito abierto. La idea es que cuando el sensor est\u00e1 horizontal est\u00e1 abierto y cuando se inclina se cierra, lo que permite detectar una determinada orientaci\u00f3n. Su aspecto y principio de funcionamiento lo vemos en la Figura A18.1. Figura A18.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A18.2). Figura A18.2. Bloques","title":"A18-Sensor de inclinaci\u00f3n (tilt)"},{"location":"tilt/#practica-a181","text":"Vamos a detectar la posici\u00f3n no vertical del sensor de orientaci\u00f3n. Encender un LED cuando el sensor de orientaci\u00f3n no est\u00e9 en posici\u00f3n vertical. El programa lo tenemos en la Figura A18.3. Figura A18.3. Soluci\u00f3n A18.1","title":"Pr\u00e1ctica A18.1"},{"location":"us/","text":"A24-Sensor de Ultrasonido SR01 V2 \u00b6 Los sensores ultras\u00f3nicos utilizan un sonar para determinar la distancia desde el sensor al objeto. Este m\u00f3dulo utiliza un chip CS100A que puede medir distancias entre 4 cm y 300 cm siendo la medida precisa y estable. El m\u00f3dulo incluye el transmisor y el receptor ultras\u00f3nicos y su circuito de control. El dispositivo debe conectarse a dos pines, por lo que utilizaremos el conector etiquetado con D3 y D4. Esto se debe a que para el funcionamiento del sensor necesita dos pines, uno para emitir el ultrasonido (Trigger) y otro para recibirlo (Echo). El principio de funcionamiento es el de la Figura A24.1. Figura A24.1. Principio de funcionamiento del sensor El sensor lo que hace es medir el tiempo (t) en microsegundos que tarda en recibir el eco del sonido emitido y como la velocidad (v) es conocida, se trata de la velocidad del sonido, que es de 340 m/s o 0.034 cm/us, la distancia vendr\u00e1 dada por la siguiente ecuaci\u00f3n: d=v \\cdot t=0.034(\\dfrac{cm}{us})\\cdot t(us)=0.034 \\cdot t(cm) d=v \\cdot t=0.034(\\dfrac{cm}{us})\\cdot t(us)=0.034 \\cdot t(cm) Aunque nosotros no debemos preocuparnos por esto puesto que el bloque ya no devuelve esta distancia medida en cm. Su aspecto lo vemos en la Figura A24.2. Figura A24.2. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A24.3). Figura A24.3. Bloques Pr\u00e1ctica A24.1 \u00b6 Vamos a medir la distancia con el sensor de ultrasonidos y mostrar el resultado en una LCD. Mostrar en una LCD la distancia que nos devuelve el sensor de ultrasonidos al poner frente al mismo un objeto a diferentes distancias. El programa lo tenemos en la Figura A24.4. Figura A24.4. Soluci\u00f3n A24.1 Pr\u00e1ctica A24.2 \u00b6 Vamos a medir la distancia con el sensor de ultrasonidos y mostrar el resultado en la consola. Mostrar por consola la velocidad medida por el sensor de ultrasonidos enviando un dato cada dos segundos. El programa lo tenemos en la Figura A24.5. Figura A24.5. Soluci\u00f3n A24.2 xxx \u00b6 xxx \u00b6 xxx \u00b6 Profundidad directorios: * Imagenes en index: (./img/\u2026..) * Archivo: (directorio/nombre-archivo) o (../directorio/nombre-archivo) * Enlace interno: (directorio/nombre-archivo) insertar bloque de c\u00f3digo: sudo do-release-upgrade Figura A01.8. Encender y apagar dos LEDs","title":"A24-Sensor de Ultrasonido"},{"location":"us/#a24-sensor-de-ultrasonido-sr01-v2","text":"Los sensores ultras\u00f3nicos utilizan un sonar para determinar la distancia desde el sensor al objeto. Este m\u00f3dulo utiliza un chip CS100A que puede medir distancias entre 4 cm y 300 cm siendo la medida precisa y estable. El m\u00f3dulo incluye el transmisor y el receptor ultras\u00f3nicos y su circuito de control. El dispositivo debe conectarse a dos pines, por lo que utilizaremos el conector etiquetado con D3 y D4. Esto se debe a que para el funcionamiento del sensor necesita dos pines, uno para emitir el ultrasonido (Trigger) y otro para recibirlo (Echo). El principio de funcionamiento es el de la Figura A24.1. Figura A24.1. Principio de funcionamiento del sensor El sensor lo que hace es medir el tiempo (t) en microsegundos que tarda en recibir el eco del sonido emitido y como la velocidad (v) es conocida, se trata de la velocidad del sonido, que es de 340 m/s o 0.034 cm/us, la distancia vendr\u00e1 dada por la siguiente ecuaci\u00f3n: d=v \\cdot t=0.034(\\dfrac{cm}{us})\\cdot t(us)=0.034 \\cdot t(cm) d=v \\cdot t=0.034(\\dfrac{cm}{us})\\cdot t(us)=0.034 \\cdot t(cm) Aunque nosotros no debemos preocuparnos por esto puesto que el bloque ya no devuelve esta distancia medida en cm. Su aspecto lo vemos en la Figura A24.2. Figura A24.2. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A24.3). Figura A24.3. Bloques","title":"A24-Sensor de Ultrasonido SR01 V2"},{"location":"us/#practica-a241","text":"Vamos a medir la distancia con el sensor de ultrasonidos y mostrar el resultado en una LCD. Mostrar en una LCD la distancia que nos devuelve el sensor de ultrasonidos al poner frente al mismo un objeto a diferentes distancias. El programa lo tenemos en la Figura A24.4. Figura A24.4. Soluci\u00f3n A24.1","title":"Pr\u00e1ctica A24.1"},{"location":"us/#practica-a242","text":"Vamos a medir la distancia con el sensor de ultrasonidos y mostrar el resultado en la consola. Mostrar por consola la velocidad medida por el sensor de ultrasonidos enviando un dato cada dos segundos. El programa lo tenemos en la Figura A24.5. Figura A24.5. Soluci\u00f3n A24.2","title":"Pr\u00e1ctica A24.2"},{"location":"us/#xxx","text":"","title":"xxx"},{"location":"us/#xxx_1","text":"","title":"xxx"},{"location":"us/#xxx_2","text":"Profundidad directorios: * Imagenes en index: (./img/\u2026..) * Archivo: (directorio/nombre-archivo) o (../directorio/nombre-archivo) * Enlace interno: (directorio/nombre-archivo) insertar bloque de c\u00f3digo: sudo do-release-upgrade Figura A01.8. Encender y apagar dos LEDs","title":"xxx"},{"location":"ventilador/","text":"A33-M\u00f3dulo ventilador L9110 \u00b6 El m\u00f3dulo se componen de un motor de corriente continua a cuyo eje se puede aplicar una peque\u00f1a h\u00e9lice que se puede usar como mini ventilador o como h\u00e9lice en si misma. El m\u00f3dulo incorpora el controlador L9110 para poder seleccionar el sentido de giro. Su aspecto lo vemos en la Figura A33.1. Figura A33.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\" (Figura A33.2). Figura A33.2. Bloques Pr\u00e1ctica A33.1 \u00b6 Vamos a hacer que el motor gire a derechas y se detenga transcurrido un tiempo que prefijamos a trav\u00e9s de una funci\u00f3n creada a tal efecto. Implementar un ventilador que se acciona mediante un pulsador y que se mantiene en funcionamiento durante el tiempo que prefijemos. El programa lo tenemos en la Figura A33.3. Figura A33.3. Soluci\u00f3n A33.1 Pr\u00e1ctica A33.2 - Propuesta \u00b6 Hacer que el motor gire en los dos sentidos para crear un ventilador de techo con posiciones de verano e invierno. El efecto ventilador verano e invierno se basa en lo siguiente: el funcionamiento m\u00e1s habitual de un ventilador de techo es impulsar el aire hacia abajo, directamente por debajo de \u00e9l girando en sentido horario. Si queremos mover el aire caliente pr\u00f3ximo al techo el ventilador debe girar en sentido contrario a las agujas del reloj, es decir, impulsando el aire hacia arriba y succionando por su parte inferior. De forma que el aire caliente se desplaza lateralmente, baja por las paredes hacia el suelo y vuelve a subir por el centro del ventilador. Implementar un ventilador que podamos configurar el modo de funcionamiento como modo verano y modo invierno pulsador.","title":"A33-M\u00f3dulo ventilador"},{"location":"ventilador/#a33-modulo-ventilador-l9110","text":"El m\u00f3dulo se componen de un motor de corriente continua a cuyo eje se puede aplicar una peque\u00f1a h\u00e9lice que se puede usar como mini ventilador o como h\u00e9lice en si misma. El m\u00f3dulo incorpora el controlador L9110 para poder seleccionar el sentido de giro. Su aspecto lo vemos en la Figura A33.1. Figura A33.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\" (Figura A33.2). Figura A33.2. Bloques","title":"A33-M\u00f3dulo ventilador L9110"},{"location":"ventilador/#practica-a331","text":"Vamos a hacer que el motor gire a derechas y se detenga transcurrido un tiempo que prefijamos a trav\u00e9s de una funci\u00f3n creada a tal efecto. Implementar un ventilador que se acciona mediante un pulsador y que se mantiene en funcionamiento durante el tiempo que prefijemos. El programa lo tenemos en la Figura A33.3. Figura A33.3. Soluci\u00f3n A33.1","title":"Pr\u00e1ctica A33.1"},{"location":"ventilador/#practica-a332-propuesta","text":"Hacer que el motor gire en los dos sentidos para crear un ventilador de techo con posiciones de verano e invierno. El efecto ventilador verano e invierno se basa en lo siguiente: el funcionamiento m\u00e1s habitual de un ventilador de techo es impulsar el aire hacia abajo, directamente por debajo de \u00e9l girando en sentido horario. Si queremos mover el aire caliente pr\u00f3ximo al techo el ventilador debe girar en sentido contrario a las agujas del reloj, es decir, impulsando el aire hacia arriba y succionando por su parte inferior. De forma que el aire caliente se desplaza lateralmente, baja por las paredes hacia el suelo y vuelve a subir por el centro del ventilador. Implementar un ventilador que podamos configurar el modo de funcionamiento como modo verano y modo invierno pulsador.","title":"Pr\u00e1ctica A33.2 - Propuesta"},{"location":"vibra/","text":"A35-Sensor de vibraci\u00f3n \u00b6 Se trata de un sensor digital que cuando se somete a vibraci\u00f3n cambia su estado de salida. El m\u00f3dulo detector de vibraci\u00f3n consta de un resorte y un poste conductor central que, ante golpes y vibraciones, el resorte reacciona desplaz\u00e1ndose de su centro y cerrando el circuito. El m\u00f3dulo dispone de un potenci\u00f3metro para ajustar su sensibilidad. A pesar de la simplicidad, se puede aprovechar para contar pasos, alarma de advertencia de colisi\u00f3n, etc. Su aspecto lo vemos en la Figura A35.1. Figura A35.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A34.2). Figura A35.2. Bloques Pr\u00e1ctica A35.1 \u00b6 Vamos a montar un sistema que cuando acerquemos un im\u00e1n se encienda un diodo LED. Implementar un programa que haga funcionar al rel\u00e9 reed como detector magn\u00e9tico en una supuesta puerta de un armario. Cuando la puerta est\u00e1 cerrada se detecta el campo magn\u00e9tico y el diodo LED est\u00e1 apagado y cuando se abre este debe apagarse. El programa lo tenemos en la Figura A34.3. Figura A35.3. Soluci\u00f3n A35.1","title":"A35-Sensor de vibraci\u00f3n"},{"location":"vibra/#a35-sensor-de-vibracion","text":"Se trata de un sensor digital que cuando se somete a vibraci\u00f3n cambia su estado de salida. El m\u00f3dulo detector de vibraci\u00f3n consta de un resorte y un poste conductor central que, ante golpes y vibraciones, el resorte reacciona desplaz\u00e1ndose de su centro y cerrando el circuito. El m\u00f3dulo dispone de un potenci\u00f3metro para ajustar su sensibilidad. A pesar de la simplicidad, se puede aprovechar para contar pasos, alarma de advertencia de colisi\u00f3n, etc. Su aspecto lo vemos en la Figura A35.1. Figura A35.1. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Sensores\" (Figura A34.2). Figura A35.2. Bloques","title":"A35-Sensor de vibraci\u00f3n"},{"location":"vibra/#practica-a351","text":"Vamos a montar un sistema que cuando acerquemos un im\u00e1n se encienda un diodo LED. Implementar un programa que haga funcionar al rel\u00e9 reed como detector magn\u00e9tico en una supuesta puerta de un armario. Cuando la puerta est\u00e1 cerrada se detecta el campo magn\u00e9tico y el diodo LED est\u00e1 apagado y cuando se abre este debe apagarse. El programa lo tenemos en la Figura A34.3. Figura A35.3. Soluci\u00f3n A35.1","title":"Pr\u00e1ctica A35.1"},{"location":"wifi/","text":"A38-M\u00f3dulo WiFi mas ESP01 \u00b6 En Easy Plug no existe como tal el m\u00f3dulo ESP-01 basado en el microcontrolador ESP8266 que permite realizar comunicaciones v\u00eda WiFi. Pero para facilitar la conexi\u00f3n de este m\u00f3dulo a la placa si se dispone de un z\u00f3calo que facilita su montaje. En este apartado vamos a hablar de como enviar datos a la nube, empezando as\u00ed a trabajar el Internet de las Cosas. La idea aqu\u00ed no es profundizar en conceptos t\u00e9cnicos como Broker, MQTT, Mosquitto, etc. Pero si que vamos a iniciarnos en el tema IoT. IoT b\u00e1sico \u00b6 \u00bfQu\u00e9 es la Internet de las Cosas? \u00b6 La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la Figura A38.1 se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Figura A38.1. Conexi\u00f3n de elementos con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026). Para conectar a la red las placas Arduino, sus clones o basadas en el mismo se usan los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo WiFi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. En la Figura A38.2 vemos los distintos m\u00f3dulos ESP. Figura A38.2. M\u00f3dulos ESP Hay otros muchos sistemas como por ejemplo ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. En la Figura A38.3 vemos estos m\u00f3dulos. Figura A38.3. Otros m\u00f3dulos ESP Un modelo destacable es la placa ESP32 STEAMakers basada en la CPU de dos n\u00facleos Xtensa LX6 con arquitectura de 32 bits y una frecuencia de trabajo de 160 MHz que integra tarjeta microSD, comunicaciones WiFi y Bluetooth y tiene el formato de un Arduino UNO. En la Figura A38.4 vemos el aspecto de esta tarjeta. Figura A38.4. ESP32 STEAMakers Introducci\u00f3n al m\u00f3dulo ESP8266 ESP-01 \u00b6 El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (los veremos a continuaci\u00f3n) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa de control del proyecto y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. El aspecto del ESP-01 lo tenemos en la Figura A38.5 y junto al mismo vemos sus principales caracter\u00edsticas. Figura A38.5. Aspecto ESP-01 Caracter\u00edsticas - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01 - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx) - La antena WiFi para la conexi\u00f3n a una internet - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n Fuente: https://programarfacil.com 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C. Programaci\u00f3n del m\u00f3dulo ESP8266 ESP-01 \u00b6 El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento aunque sea de forma breve. Modo de funcionamiento UART. Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines: \u25e6 GPIO0 = 0 (nivel bajo o LOW = 0 V) \u25e6 GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash. Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: \u25e6 GPIO0 = 1 \u25e6 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa y en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino, que no vamos a explicar aqu\u00ed, o por medio de un convertidor USB-serie igual o similar al de la Figura A38.6. Figura A38.6. Convertidor USB-serie Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concreto el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar. Comando AT en el ESP8266 \u00b6 El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa retorno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa ( Espressif Systems ) con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Preparaci\u00f3n del m\u00f3dulo ESP-01 \u00b6 Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la Figura A38.7. Figura A38.7. Consola con comando AT Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la que vemos en la Figura A38.8. Figura A38.8. Respuesta correcta a comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. En la Figura A38.9 vemos como el m\u00f3dulo ha quedado configurado a 9600 baudios. Figura A38.9. Comando AT para configurar a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de https://thingspeak.com , pero antes de nada vamos a describir que es MQTT. Una introducci\u00f3n al IoT a trav\u00e9s de MQTT \u00b6 Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT . Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamenta, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la subscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo como el de la Figura A38.10 lo podemos ver m\u00e1s claramente. Figura A38.10. Estructura jer\u00e1rquica de topics Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura De esta forma podemos suscribirnos a un topic concreto o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft AWS de Amazon CloudMQTT , disponible en: https://www.cloudmqtt.com/plans.html ThingSpeak de Mathworks (MATLAB) Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse: Enlace - Direcci\u00f3n del broker Mosquitto: Enlace - Direcci\u00f3n del broker HiveMQ: Enlace - Direcci\u00f3n del broker Thingspeak: Enlace \u2013 Direcci\u00f3n del broker Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida. Creaci\u00f3n de un canal en un servidor MQTT \u00b6 En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la Figura A38.11. Figura A38.11. Sign Up en Thinspeak Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la Figura A38.12 siguiente. Figura A38.12. Aceptar direcci\u00f3n de correo Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la Figura A38.13. Figura A38.13. Confirmar direcci\u00f3n de correo Un vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la iFigura A38.14. Figura A38.14. Acceso a Thingspeak La primera vez que accedamos con nuestro correo y contrase\u00f1a se nos mostrar\u00e1 una p\u00e1gina con informaci\u00f3n de uso y los acuerdos de MathWorks para sus servicios online que debemos aceptar. En la Figura A38.15 vemos esta informaci\u00f3n de uso. Figura A38.15. Informaci\u00f3n de uso Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo, tal y como se aprecia en la Figura A38.16. Figura A38.16. Acceso a Thingspeak completado Pasos iniciales con MQTT \u00b6 En ThingSpeak el funcionamiento est\u00e1 basado en canales por lo que, una vez logueados, lo primero que vamos a hacer es crear un nuevo canal con las caracter\u00edsticas que vemos en la Figura A38.17. Figura A38.17. Crear canal Si nos desplazamos hac\u00eda abajo en la misma p\u00e1gina encontramos este bot\u00f3n: Y ser\u00e1 en este canal donde veremos los datos una vez hagamos nuestro programa en ArduinoBlocks. El bloque de inicializaci\u00f3n de la conexi\u00f3n con el broker en ArduinoBlocks para la versi\u00f3n Easy Plug lo vemos en la Figura A38.18. Figura A38.18. Inicializar conexi\u00f3n El bloque para publicar datos (Figura A38.19) ahora simplemente lleva el n\u00famero de identificaci\u00f3n del canal (Channel ID) y el campo (Field) que corresponda con la variable a publicar que seleccionamos con el desplegable. Es muy importante respetar el orden de los campos establecido (seg\u00fan los programas a importar y la comunicaci\u00f3n de correo realizada para comunicar los datos de configuraci\u00f3n) para que los resultados sean correctos. Figura A38.19. Bloque publicar datos Cuando entramos en uno de los canales creados en el broker disponemos de una serie de pesta\u00f1as para trabajar y configurar dicho canal, en concreto en la pesta\u00f1a API Keys encontraremos la informaci\u00f3n necesaria para el bloque anterior, es decir la ID del canal y la llave API para publicar, tal y como vemos en la Figura A38.20. Figura A38.20. Configuraci\u00f3n del canal Entre cada envio de datos debemos poner un bloque esperar de como m\u00ednimo 16 segundos. Esto es muy importante porque la versi\u00f3n gratuita de ThingSpeak s\u00f3lo permite subir datos con ese intervalo de tiempo. A\u00f1adir canales a MQTT en ThingSpeak \u00b6 El proceso es sencillo y se lanza desde el men\u00fa horizontal de ThingSpeak, tal y como vemos en la Figura A38.21. Figura A38.21. A\u00f1adir MQTT Es conveniente copiar o guardar los datos indicados para tenerlos a mano, en especial la contrase\u00f1a, porque en el momento que salgamos de esta ventana ya no la podremos recuperar aunque si regenerar. Tras hacer clic en MQTT se nos mostrar\u00e1 una nueva ventana con los canales a\u00f1adidos (en blanco si no hemos a\u00f1adido ninguno) y un bot\u00f3n verde con la leyenda \u201cAdd a new device\u201d que nos va a permitir a\u00f1adir nuevos dispositivos. En la Figura A38.22 vemos la ventana citada. Figura A38.22. A\u00f1adir nuevo dispositivo MQTT En \u201cDevice information\u201d damos los datos identificativos del dispositivo MQTT, siendo \u201cName\u201d un campo obligatorio a cumplimentar y \u201cDescription\u201d un campo opcional para dar mas detalles del dispositivo. La parte realmente importante es \u201cAuthorize channels to access que vemos seguidamente. Si hacemos clic en el desplegable se nos mostrar\u00e1 una ventana con el listados de dispositivos candidatos en \u201cYour Recent Channels\u201d. Si el canal que queremos a\u00f1adir est\u00e1 en la lista lo seleccionamos con un clic y continuamos el proceso como veremos posteriormente. En la Figura A38.23 vemos esta situaci\u00f3n. Figura A38.23. Lista dispositivo para a\u00f1adir a MQTT Si el canal no lo encontramos en la lista escogemos la opci\u00f3n marcada en la Figura A38.24. Figura A38.24. Otra opci\u00f3n para a\u00f1adir a MQTT En la ventana que se muestra ahora (Figura A38.25) tenemos habilitado el campo para introducir un \u201cChannel ID\u201d v\u00e1lido que nos habilitar\u00e1 el bot\u00f3n \u201cAdd Channel\u201d. Figura A38.25. Al tener un Channel ID v\u00e1lido se habilita Add Channel Al hacer clic en el bot\u00f3n verde se a\u00f1ade el canal como dispositivo MQTT y veremos algo similar a la Figura A38.26. Figura A38.26. Canal autorizado La configuraci\u00f3n por defecto permite publicar en el dispositivo \u201cAllow Publish\u201d y permite suscripciones \u201cAllow Subscribe\u201d y ambos podemos deseleccionarlos o dejarlos como est\u00e1n seg\u00fan nuestras necesidades. El aspa a la derecha nos permite eliminar el canal como dispositivo MQTT. El proceso cuando seleccionamos un canal de la lista que nos muestra es totalmente similar al descrito cuando introducimos un n\u00famero v\u00e1lido de canal. Si en el campo para introducir un ID de canal tecleamos algo no v\u00e1lido se mostrar\u00e1 un mensaje como el que vemos en la Figura A38.27 y el bot\u00f3n \u201cAdd Channel\u201d permanece inactivo. Figura A38.27. Error en Channel ID Literalmente el error nos indica que introduzcamos el ID de un canal p\u00fablico o el de uno de nuestros propios canales. Cuando toda la informaci\u00f3n introducida es correcta se activa el bot\u00f3n \u201cAdd Device\u201d (ver Figura A38.28) y si hacemos clic el canal queda a\u00f1adido como dispositivo MQTT en ThingSpeak. Figura A38.28. Bot\u00f3n Add Device activo Tras hacer clic en el bot\u00f3n \u201cAdd Device\u201d se nos muestra una ventana como la de la Figura A38.28, donde se han realizado las descripciones pertinentes de sus apartados. Figura A38.29. Nuevo dispositivo a\u00f1adido El nuevo dispositivo se mostrar\u00e1 en la venta \u201cMQTT Devices\u201d de la forma que vemos en la Figura A38.30. Figura A38.30. Lista de dispositivos MQTT Desde esta ventana podemos eliminar el dispositivo o editar su configuraci\u00f3n, para, por ejemplo regenerar la contrase\u00f1a. Configuraciones en ArduinoBlocks \u00b6 El primer bloque que vamos a configurar es el que tenemos en Inicializar. Es el bloque encargado de establecer la configuraci\u00f3n de nuestra conexi\u00f3n WiFi (Figura A38.31) con el m\u00f3dulo ESP8266 que vamos a utilizar. Figura A38.31. Bloque configuraciones en ArduinoBlocks Configuramos el bloque de la siguiente forma: WiFi red: debemos poner el nombre de nuestra conexi\u00f3n WiFi Clave: tecleamos la contrase\u00f1a de acceso a nuestra red WiFi Broker: tecleamos el nombre del broker que es mqtt3.thingspeak.com Cliente Id: sustituimos \u201cclientId =\u201d por el valor generado en la plataforma al crear el dispositivo MQTT \u201cDevices -> MQTT y Add a new device\u201d. Usuario: sustituimos \u201cusername =\u201d por el valor generado en la plataforma. Clave: sustituimos \u201cpassword =\u201d por el valor generado en la plataforma. El resto de casillas las dejamos como vemos en la imagen anterior. En segundo lugar, configuramos los bloques contenidos en la funci\u00f3n subir datos a la nube. El bloque Publicar Tema solamente requiere del identificador del canal \u201cChannel ID\u201d y que seleccionemos el campo para cada caso tal y como se muestra en la Figura A38.32. Figura A38.32. Bloque publicar Debemos configurar para cada par\u00e1metro a subir: Channel ID: Es el n\u00famero identificador del canal en el que vamos a escribir los datos que enviemos. Field: Es el campo seleccionado para mostrar. Ambos datos se obtienen de la informaci\u00f3n suministrada por el servidor ThingSpeak para cada canal y no ser\u00e1n alterados salvo que se detecte una total inactividad del canal, bien por estar desatendido o bien porque hemos dejado de utilizarlo. El aspecto de los elementos a utilizar para la conexi\u00f3n WiFi lo vemos en la Figura A38.33. Figura A38.33. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Comunicaciones \u2192 WiFi \u2192 MQTT (IoT)\" (Figura A38.34). Figura A38.34. Bloques Pr\u00e1ctica A38.1 \u00b6 Vamos a medir la temperatura ambiente y la humedad de una habitaci\u00f3n y publicarlas en Thingspeak. Crear el programa en ArduinoBlocks y publicar en Thingspeak la temperatura y la humedad medidas por un sensor DHT22. Necesitaremos crearnos una cuenta si no disponemos de ella, crear el canal y crear el dispositivo MQTT. Primero: Thingspeak \u00b6 Crearemos el canal tal y como vemos en la Figura A38.35. Salvamos los cambios con el bot\u00f3n que hay al final. Figura A38.35. Creaci\u00f3n del canal en Thingspeak Hacemos que el canal sea p\u00fablico. Vemos el apartado API Keys. A\u00f1adimos un nuevo dispositivo MQTT: Una vez a\u00f1adido se nos muestran los datos de las credenciales para poder publicar y que debemos preservar bien copiando cada campo o bien descargando las credenciales. Al pulsar el bot\u00f3n Done se nos muestra el dispositivo MQTT creado: Segundo: ArduinoBlocks \u00b6 Vamos ahora a crear el programa para grabarlo en la placa y comenzar a emitir datos y subirlos al canal creado. Un programa como el de la Figura A38.36. Figura A38.36. Soluci\u00f3n A38.1 El programa arrojar los resultados que vemos en la Figura A38.37. Figura A38.37. Resultados A38.1","title":"A38-M\u00f3dulo WiFi mas ESP01"},{"location":"wifi/#a38-modulo-wifi-mas-esp01","text":"En Easy Plug no existe como tal el m\u00f3dulo ESP-01 basado en el microcontrolador ESP8266 que permite realizar comunicaciones v\u00eda WiFi. Pero para facilitar la conexi\u00f3n de este m\u00f3dulo a la placa si se dispone de un z\u00f3calo que facilita su montaje. En este apartado vamos a hablar de como enviar datos a la nube, empezando as\u00ed a trabajar el Internet de las Cosas. La idea aqu\u00ed no es profundizar en conceptos t\u00e9cnicos como Broker, MQTT, Mosquitto, etc. Pero si que vamos a iniciarnos en el tema IoT.","title":"A38-M\u00f3dulo WiFi mas ESP01"},{"location":"wifi/#iot-basico","text":"","title":"IoT b\u00e1sico"},{"location":"wifi/#que-es-la-internet-de-las-cosas","text":"La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la Figura A38.1 se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Figura A38.1. Conexi\u00f3n de elementos con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026). Para conectar a la red las placas Arduino, sus clones o basadas en el mismo se usan los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo WiFi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. En la Figura A38.2 vemos los distintos m\u00f3dulos ESP. Figura A38.2. M\u00f3dulos ESP Hay otros muchos sistemas como por ejemplo ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. En la Figura A38.3 vemos estos m\u00f3dulos. Figura A38.3. Otros m\u00f3dulos ESP Un modelo destacable es la placa ESP32 STEAMakers basada en la CPU de dos n\u00facleos Xtensa LX6 con arquitectura de 32 bits y una frecuencia de trabajo de 160 MHz que integra tarjeta microSD, comunicaciones WiFi y Bluetooth y tiene el formato de un Arduino UNO. En la Figura A38.4 vemos el aspecto de esta tarjeta. Figura A38.4. ESP32 STEAMakers","title":"\u00bfQu\u00e9 es la Internet de las Cosas?"},{"location":"wifi/#introduccion-al-modulo-esp8266-esp-01","text":"El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (los veremos a continuaci\u00f3n) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa de control del proyecto y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. El aspecto del ESP-01 lo tenemos en la Figura A38.5 y junto al mismo vemos sus principales caracter\u00edsticas. Figura A38.5. Aspecto ESP-01 Caracter\u00edsticas - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01 - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx) - La antena WiFi para la conexi\u00f3n a una internet - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n Fuente: https://programarfacil.com 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C.","title":"Introducci\u00f3n al m\u00f3dulo ESP8266 ESP-01"},{"location":"wifi/#programacion-del-modulo-esp8266-esp-01","text":"El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento aunque sea de forma breve. Modo de funcionamiento UART. Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines: \u25e6 GPIO0 = 0 (nivel bajo o LOW = 0 V) \u25e6 GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash. Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: \u25e6 GPIO0 = 1 \u25e6 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa y en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino, que no vamos a explicar aqu\u00ed, o por medio de un convertidor USB-serie igual o similar al de la Figura A38.6. Figura A38.6. Convertidor USB-serie Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concreto el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar.","title":"Programaci\u00f3n del m\u00f3dulo ESP8266 ESP-01"},{"location":"wifi/#comando-at-en-el-esp8266","text":"El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa retorno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa ( Espressif Systems ) con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos.","title":"Comando AT en el ESP8266"},{"location":"wifi/#preparacion-del-modulo-esp-01","text":"Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la Figura A38.7. Figura A38.7. Consola con comando AT Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la que vemos en la Figura A38.8. Figura A38.8. Respuesta correcta a comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. En la Figura A38.9 vemos como el m\u00f3dulo ha quedado configurado a 9600 baudios. Figura A38.9. Comando AT para configurar a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de https://thingspeak.com , pero antes de nada vamos a describir que es MQTT.","title":"Preparaci\u00f3n del m\u00f3dulo ESP-01"},{"location":"wifi/#una-introduccion-al-iot-a-traves-de-mqtt","text":"Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT . Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamenta, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la subscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo como el de la Figura A38.10 lo podemos ver m\u00e1s claramente. Figura A38.10. Estructura jer\u00e1rquica de topics Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura De esta forma podemos suscribirnos a un topic concreto o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft AWS de Amazon CloudMQTT , disponible en: https://www.cloudmqtt.com/plans.html ThingSpeak de Mathworks (MATLAB) Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse: Enlace - Direcci\u00f3n del broker Mosquitto: Enlace - Direcci\u00f3n del broker HiveMQ: Enlace - Direcci\u00f3n del broker Thingspeak: Enlace \u2013 Direcci\u00f3n del broker Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida.","title":"Una introducci\u00f3n al IoT a trav\u00e9s de MQTT"},{"location":"wifi/#creacion-de-un-canal-en-un-servidor-mqtt","text":"En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la Figura A38.11. Figura A38.11. Sign Up en Thinspeak Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la Figura A38.12 siguiente. Figura A38.12. Aceptar direcci\u00f3n de correo Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la Figura A38.13. Figura A38.13. Confirmar direcci\u00f3n de correo Un vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la iFigura A38.14. Figura A38.14. Acceso a Thingspeak La primera vez que accedamos con nuestro correo y contrase\u00f1a se nos mostrar\u00e1 una p\u00e1gina con informaci\u00f3n de uso y los acuerdos de MathWorks para sus servicios online que debemos aceptar. En la Figura A38.15 vemos esta informaci\u00f3n de uso. Figura A38.15. Informaci\u00f3n de uso Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo, tal y como se aprecia en la Figura A38.16. Figura A38.16. Acceso a Thingspeak completado","title":"Creaci\u00f3n de un canal en un servidor MQTT"},{"location":"wifi/#pasos-iniciales-con-mqtt","text":"En ThingSpeak el funcionamiento est\u00e1 basado en canales por lo que, una vez logueados, lo primero que vamos a hacer es crear un nuevo canal con las caracter\u00edsticas que vemos en la Figura A38.17. Figura A38.17. Crear canal Si nos desplazamos hac\u00eda abajo en la misma p\u00e1gina encontramos este bot\u00f3n: Y ser\u00e1 en este canal donde veremos los datos una vez hagamos nuestro programa en ArduinoBlocks. El bloque de inicializaci\u00f3n de la conexi\u00f3n con el broker en ArduinoBlocks para la versi\u00f3n Easy Plug lo vemos en la Figura A38.18. Figura A38.18. Inicializar conexi\u00f3n El bloque para publicar datos (Figura A38.19) ahora simplemente lleva el n\u00famero de identificaci\u00f3n del canal (Channel ID) y el campo (Field) que corresponda con la variable a publicar que seleccionamos con el desplegable. Es muy importante respetar el orden de los campos establecido (seg\u00fan los programas a importar y la comunicaci\u00f3n de correo realizada para comunicar los datos de configuraci\u00f3n) para que los resultados sean correctos. Figura A38.19. Bloque publicar datos Cuando entramos en uno de los canales creados en el broker disponemos de una serie de pesta\u00f1as para trabajar y configurar dicho canal, en concreto en la pesta\u00f1a API Keys encontraremos la informaci\u00f3n necesaria para el bloque anterior, es decir la ID del canal y la llave API para publicar, tal y como vemos en la Figura A38.20. Figura A38.20. Configuraci\u00f3n del canal Entre cada envio de datos debemos poner un bloque esperar de como m\u00ednimo 16 segundos. Esto es muy importante porque la versi\u00f3n gratuita de ThingSpeak s\u00f3lo permite subir datos con ese intervalo de tiempo.","title":"Pasos iniciales con MQTT"},{"location":"wifi/#anadir-canales-a-mqtt-en-thingspeak","text":"El proceso es sencillo y se lanza desde el men\u00fa horizontal de ThingSpeak, tal y como vemos en la Figura A38.21. Figura A38.21. A\u00f1adir MQTT Es conveniente copiar o guardar los datos indicados para tenerlos a mano, en especial la contrase\u00f1a, porque en el momento que salgamos de esta ventana ya no la podremos recuperar aunque si regenerar. Tras hacer clic en MQTT se nos mostrar\u00e1 una nueva ventana con los canales a\u00f1adidos (en blanco si no hemos a\u00f1adido ninguno) y un bot\u00f3n verde con la leyenda \u201cAdd a new device\u201d que nos va a permitir a\u00f1adir nuevos dispositivos. En la Figura A38.22 vemos la ventana citada. Figura A38.22. A\u00f1adir nuevo dispositivo MQTT En \u201cDevice information\u201d damos los datos identificativos del dispositivo MQTT, siendo \u201cName\u201d un campo obligatorio a cumplimentar y \u201cDescription\u201d un campo opcional para dar mas detalles del dispositivo. La parte realmente importante es \u201cAuthorize channels to access que vemos seguidamente. Si hacemos clic en el desplegable se nos mostrar\u00e1 una ventana con el listados de dispositivos candidatos en \u201cYour Recent Channels\u201d. Si el canal que queremos a\u00f1adir est\u00e1 en la lista lo seleccionamos con un clic y continuamos el proceso como veremos posteriormente. En la Figura A38.23 vemos esta situaci\u00f3n. Figura A38.23. Lista dispositivo para a\u00f1adir a MQTT Si el canal no lo encontramos en la lista escogemos la opci\u00f3n marcada en la Figura A38.24. Figura A38.24. Otra opci\u00f3n para a\u00f1adir a MQTT En la ventana que se muestra ahora (Figura A38.25) tenemos habilitado el campo para introducir un \u201cChannel ID\u201d v\u00e1lido que nos habilitar\u00e1 el bot\u00f3n \u201cAdd Channel\u201d. Figura A38.25. Al tener un Channel ID v\u00e1lido se habilita Add Channel Al hacer clic en el bot\u00f3n verde se a\u00f1ade el canal como dispositivo MQTT y veremos algo similar a la Figura A38.26. Figura A38.26. Canal autorizado La configuraci\u00f3n por defecto permite publicar en el dispositivo \u201cAllow Publish\u201d y permite suscripciones \u201cAllow Subscribe\u201d y ambos podemos deseleccionarlos o dejarlos como est\u00e1n seg\u00fan nuestras necesidades. El aspa a la derecha nos permite eliminar el canal como dispositivo MQTT. El proceso cuando seleccionamos un canal de la lista que nos muestra es totalmente similar al descrito cuando introducimos un n\u00famero v\u00e1lido de canal. Si en el campo para introducir un ID de canal tecleamos algo no v\u00e1lido se mostrar\u00e1 un mensaje como el que vemos en la Figura A38.27 y el bot\u00f3n \u201cAdd Channel\u201d permanece inactivo. Figura A38.27. Error en Channel ID Literalmente el error nos indica que introduzcamos el ID de un canal p\u00fablico o el de uno de nuestros propios canales. Cuando toda la informaci\u00f3n introducida es correcta se activa el bot\u00f3n \u201cAdd Device\u201d (ver Figura A38.28) y si hacemos clic el canal queda a\u00f1adido como dispositivo MQTT en ThingSpeak. Figura A38.28. Bot\u00f3n Add Device activo Tras hacer clic en el bot\u00f3n \u201cAdd Device\u201d se nos muestra una ventana como la de la Figura A38.28, donde se han realizado las descripciones pertinentes de sus apartados. Figura A38.29. Nuevo dispositivo a\u00f1adido El nuevo dispositivo se mostrar\u00e1 en la venta \u201cMQTT Devices\u201d de la forma que vemos en la Figura A38.30. Figura A38.30. Lista de dispositivos MQTT Desde esta ventana podemos eliminar el dispositivo o editar su configuraci\u00f3n, para, por ejemplo regenerar la contrase\u00f1a.","title":"A\u00f1adir canales a MQTT en ThingSpeak"},{"location":"wifi/#configuraciones-en-arduinoblocks","text":"El primer bloque que vamos a configurar es el que tenemos en Inicializar. Es el bloque encargado de establecer la configuraci\u00f3n de nuestra conexi\u00f3n WiFi (Figura A38.31) con el m\u00f3dulo ESP8266 que vamos a utilizar. Figura A38.31. Bloque configuraciones en ArduinoBlocks Configuramos el bloque de la siguiente forma: WiFi red: debemos poner el nombre de nuestra conexi\u00f3n WiFi Clave: tecleamos la contrase\u00f1a de acceso a nuestra red WiFi Broker: tecleamos el nombre del broker que es mqtt3.thingspeak.com Cliente Id: sustituimos \u201cclientId =\u201d por el valor generado en la plataforma al crear el dispositivo MQTT \u201cDevices -> MQTT y Add a new device\u201d. Usuario: sustituimos \u201cusername =\u201d por el valor generado en la plataforma. Clave: sustituimos \u201cpassword =\u201d por el valor generado en la plataforma. El resto de casillas las dejamos como vemos en la imagen anterior. En segundo lugar, configuramos los bloques contenidos en la funci\u00f3n subir datos a la nube. El bloque Publicar Tema solamente requiere del identificador del canal \u201cChannel ID\u201d y que seleccionemos el campo para cada caso tal y como se muestra en la Figura A38.32. Figura A38.32. Bloque publicar Debemos configurar para cada par\u00e1metro a subir: Channel ID: Es el n\u00famero identificador del canal en el que vamos a escribir los datos que enviemos. Field: Es el campo seleccionado para mostrar. Ambos datos se obtienen de la informaci\u00f3n suministrada por el servidor ThingSpeak para cada canal y no ser\u00e1n alterados salvo que se detecte una total inactividad del canal, bien por estar desatendido o bien porque hemos dejado de utilizarlo. El aspecto de los elementos a utilizar para la conexi\u00f3n WiFi lo vemos en la Figura A38.33. Figura A38.33. Aspecto En el apartado de bloques de programaci\u00f3n, se encuentra en \"Comunicaciones \u2192 WiFi \u2192 MQTT (IoT)\" (Figura A38.34). Figura A38.34. Bloques","title":"Configuraciones en ArduinoBlocks"},{"location":"wifi/#practica-a381","text":"Vamos a medir la temperatura ambiente y la humedad de una habitaci\u00f3n y publicarlas en Thingspeak. Crear el programa en ArduinoBlocks y publicar en Thingspeak la temperatura y la humedad medidas por un sensor DHT22. Necesitaremos crearnos una cuenta si no disponemos de ella, crear el canal y crear el dispositivo MQTT.","title":"Pr\u00e1ctica A38.1"},{"location":"wifi/#primero-thingspeak","text":"Crearemos el canal tal y como vemos en la Figura A38.35. Salvamos los cambios con el bot\u00f3n que hay al final. Figura A38.35. Creaci\u00f3n del canal en Thingspeak Hacemos que el canal sea p\u00fablico. Vemos el apartado API Keys. A\u00f1adimos un nuevo dispositivo MQTT: Una vez a\u00f1adido se nos muestran los datos de las credenciales para poder publicar y que debemos preservar bien copiando cada campo o bien descargando las credenciales. Al pulsar el bot\u00f3n Done se nos muestra el dispositivo MQTT creado:","title":"Primero: Thingspeak"},{"location":"wifi/#segundo-arduinoblocks","text":"Vamos ahora a crear el programa para grabarlo en la placa y comenzar a emitir datos y subirlos al canal creado. Un programa como el de la Figura A38.36. Figura A38.36. Soluci\u00f3n A38.1 El programa arrojar los resultados que vemos en la Figura A38.37. Figura A38.37. Resultados A38.1","title":"Segundo: ArduinoBlocks"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Wikipedia Manual de la placa en catal\u00e1n Manual EasyPlug Versi\u00f3n en espa\u00f1ol del Manual EasyPlug Wiki de keyestudio sobre la placa y los elementos usados Wiki keyestudio, Category:EASY Plug Manuales de ArduinoBlocks","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Wikipedia Manual de la placa en catal\u00e1n Manual EasyPlug Versi\u00f3n en espa\u00f1ol del Manual EasyPlug Wiki de keyestudio sobre la placa y los elementos usados Wiki keyestudio, Category:EASY Plug Manuales de ArduinoBlocks","title":"Webgraf\u00eda y bibliograf\u00eda"}]}